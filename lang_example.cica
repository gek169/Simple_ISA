//a comment
#a different comment
//this is a compound type declaration.
//When a struct is declared, its assignment operator (=) and period operator (.) is defined.
//assignment of a struct is exactly the same as recursively assigning its primitives (Loads and stores)
//assignment of a pointer is a built-in operation which happens as one short assignment
//and one byte assignment.
//Structs may contain only primitives.
struct{
	short a;
	byte b;
//Pointers are three bytes.
	//All pointer-based memory accesses are far-indexed.
	ptr(byte) c;
} mytype;

//Function names are compiletime constants.
//functions place their return values on the stack.
//functions recieve their arguments in-order on the stack.
//a function guarantees that it will pop the arguments from the stack and leave only the return value.
//Function declarations automatically resolve "where" in the stack they must write their return value

proc mytype myfunction(mytype X) {
#myfunction self-analyzes and realizes...
#1) its body takes up 12 bytes of stack (The function arguments being the first.)
#2) its return value is 6 bytes
#3) the location to write the return value is therefore the stack pointer minus 6.
//        Stack pointer
//   		   V
// XXXXXXQQQQQQ_______
// ^
// Where the "return" statement writes its value.

	mytype q;
//Prerecognition: This statement contains no far memory variables.
//Prerecognition: lvalue type of assignment is "short"
//the right hand side must eventually resolve to a short.
//Normal indexing can be used.
//To resolve this first statement, we must first resolve q.a and put it on the stack
//it is located on the stack but we need to put a pointer to it on the stack so we know what to write to.
//astp;llb 0,4;sub;alpush;
//
//We now must resolve the right hand side- it is an integer literal.
//lla 0,0;alpush;
//

	q.a=0;
	q.b=X.b;
	q.c[0]=0;
//This statement 
	return q;
}
short mulshorts(short, short);
do_someting_to_mytype(mytpe);

#global variables must specify a storage location
#there are three kinds:
#AT: located anywhere in the 16MB address space.
#AT_HOME: located specifically within the first 64k.
byte AT[0xffeeaa] far_globalbyte;
#loads and stores for AT_HOME 
byte AT_HOME[0xeeaa] home_globalbyte;

#__start is placed automatically at 0x10000 regardless of where you put it in your file.
#returns inside of start are automatically resolved to the halt instruction;

proc void __start(){
#You may also write comments inside of functions.
#the storage space for a is presumed to be stack (stack is a keyword) but you may put it anywhere.
	mytype a;
#operator= between lrvalue ptr(byte) and compiletime constant lrvalue ptr(byte)
	a.c=&far_globalbyte;
	globalbyte=7;
}

#the location of this procedure will be automatically resolved outside the home page.
proc mytype myfunction(){
	
}
RESERVE_SPACE 
