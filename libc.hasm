//	SISA16 "LIBC" STANDARD LIBRARY
// Intended to fit in a single region.
// (C) David M.H.S. Webster 2021
// Written for the Public Domain.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~Let all that you do be done with love~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

section 0x20000;asm_begin_region_restriction;

//EMULATION STATION~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//This must be placed at a region boundary, so it must be first.
//Both of the following functions take a jump point in RX0.
//They take a page to share with the client in the second parameter, so memory can be shared.
//Register A (upon return) is the return value from the containerized machine, so you can use the error code if there was one.

//Copy shit.
farldrx0 %&libc_emulate_stack_data_store%
farstrx0 %&0%
.libc_emulate_jumploc:@+1+
lrx0 %/0%; 
farjmprx0;
:libc_emulate_stack_data_store:
nop;nop;nop;nop;

//Both of these functions use register B to store the page that 

..decl_farproc:proc_emulate
	//We are passed a place to jump to in RX0.
	farstrx0 %&libc_emulate_jumploc%;
	//We must memcpy three bytes, so we memcpy 4.
	farldrx0 %&0%
	farstrx0 %&libc_emulate_stack_data_store%
	sc %0%; la 2; ista; //la
	adecr;ca;			//put 1 into c.
	lla %0x244%; istla;	//2- the region we want to jump to. lfarpc is 0x44.
	ab;
	emulate;
	//restore stack integrity.
		farldrx0 %&libc_emulate_stack_data_store%
		farstrx0 %&0%
	//a holds the value
farret;

..decl_farproc:proc_emulate_seg
	//We are passed a place to jump to in RX0.
	farstrx0 %&libc_emulate_jumploc%;
	//copy four bytes from the bottom of the stack for the bootloader.
	farldrx0 %&0%
	farstrx0 %&libc_emulate_stack_data_store%
	sc %0%; la 2; ista; 	//la
	adecr;ca;				//put 1 into c.
	lla %0x244%; istla;		//2- the region we want to jump to. lfarpc is 0x44.
	ab;
	emulate_seg;
	//restore stack integrity.
		farldrx0 %&libc_emulate_stack_data_store%
		farstrx0 %&0%
	//a holds the return value.
farret;


..decl_farproc:proc_printbytehex
	//retrieve our argument.
		astp;lb4;sub;ca;ilda;
	//push it
		apush
		lb 4;rsh;
		lb0xf;and;
		lb 6;mul;
	llb %libc_printbytehex_jmptable_1%; add;ca;jmp;
	:libc_printbytehex_jmptable_1:
		la0x30;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x31;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x32;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x33;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x34;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x35;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x36;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x37;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x38;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x39;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x41;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x42;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x43;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x44;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x45;sc%libc_printbytehex_jmptable_1_end%;jmp
		la0x46;sc%libc_printbytehex_jmptable_1_end%;jmp
	:libc_printbytehex_jmptable_1_end:
	putchar
	apop;lb 15;and;lb6;mul;
	llb%libc_printbytehex_jmptable_2%;add;ca;jmp;
	:libc_printbytehex_jmptable_2:
		la0x30;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x31;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x32;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x33;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x34;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x35;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x36;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x37;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x38;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x39;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x41;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x42;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x43;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x44;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x45;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x46;sc%libc_printbytehex_jmptable_2_end%;jmp
	:libc_printbytehex_jmptable_2_end:
	putchar
farret

..decl_farproc:proc_printbytelchex
	//retrieve our argument.
		astp;lb4;sub;ca;ilda;
	//push it
		apush
		lb 4;rsh;
		lb0xf;and;
		lb 6;mul;
	llb %libc_printbytelchex_jmptable_1%; add;ca;jmp;
	:libc_printbytelchex_jmptable_1:
		la0x30;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x31;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x32;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x33;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x34;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x35;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x36;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x37;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x38;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x39;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x61;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x62;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x63;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x64;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x65;sc%libc_printbytelchex_jmptable_1_end%;jmp
		la0x66;sc%libc_printbytelchex_jmptable_1_end%;jmp
	:libc_printbytelchex_jmptable_1_end:
	putchar
	apop;lb 15;and;lb6;mul;
	llb%libc_printbytelchex_jmptable_2%;add;ca;jmp;
	:libc_printbytelchex_jmptable_2:
		la0x30;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x31;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x32;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x33;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x34;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x35;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x36;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x37;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x38;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x39;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x61;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x62;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x63;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x64;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x65;sc%libc_printbytehex_jmptable_2_end%;jmp
		la0x66;sc%libc_printbytehex_jmptable_2_end%;jmp
	//We can re-use the same ending from printbytehex.

//PUTS~~~~~~~~~~~~~~~
//CLOBBERS: A, B, C, RX0, RX1
..decl_farproc:proc_puts
	//Grab the far pointer.
	astp; lb 6; sub; ca; ildb;
	rx0b; lb16; rx1b; rxlsh;
	aincr; ca; illdb; 
	rx1b; rxadd;
	:libc_puts_looptop:
		cbrx0;
		farilda;
		apush;
		lb0;cmp;bpop;sc%libc_puts_loopend%;jmpifeq;
		ab
		putchar
		rxincr;
	sc %libc_puts_looptop%;jmp;
	:libc_puts_loopend:
farret;


//STRLEN~~~~~~~~~~~~~~~~~~~~~~
//Clobbers: A, B, C, RX0, RX1, RX2
..decl_farproc:proc_strlen
	//Grab the far pointer.
	astp; lb 6; sub; ca; ildb;
	rx0b; lb16; rx1b; rxlsh;
	aincr; ca; illdb; 
	rx1b; rxadd;
	//It's in RX0.
	//we now have our far pointer! put it on the top of the stack for easy access.
	//we actually push 4 bytes, so we can rx0pop.
	rx1_0;
	lb0;rx2b;
	:libc_strlen_looptop:
		rx0_1;	cbrx0;
		farilda;
		lb0;		cmp;	sc%libc_strlen_loopend%;	jmpifeq;
		rxincr;		rx1_0;
		rx0_2;		rxincr;		rx2_0;
		sc %libc_strlen_looptop%;jmp;
	:libc_strlen_loopend:
		rx0_2;								//move RX2 to RX0 so we can keep it.
		astp;lb5;sub;ca;
		arx0; istla							//get the low 16 bits.
		lb16;rx1b;
		rxrsh
		astp;lb6;sub;ca;
		arx0; ista;
farret;

//MEMCPY~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//Clobbers: A,B,C, RX0, RX1, RX2, RX3.
//RETURNS: Nothing.
//ARGS:
//src: RX1
//dest: RX0
//bytes: RX2
:libc_mcpy_src:
nop;nop;nop;nop;

..decl_farproc:proc_memcpy
	rx3_0;
	farstrx1 %&libc_mcpy_src%;
	lb0;rx1b;
	:libc_mcpy_looptop:
		//Quit? if not, decrement.
		rx0_2 
		rxcmp
		sc %libc_mcpy_loopend%; jmpifeq;
		rxdecr
		rx2_0
		
		//load a single byte.
		farldrx0 %&libc_mcpy_src%
		cbrx0
		farilda
		rxincr
		farstrx0 %&libc_mcpy_src%
		//store that single byte.
		rx0_3
			cbrx0
			farista
			rxincr
		rx3_0
		sc %libc_mcpy_looptop%; jmp;
	:libc_mcpy_loopend:
farret;

//GETS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//Clobbers: A, B, C, RX0, RX1, RX2, RX3
//Designed for interactive mode.
//Limit of 0xffFE characters.
.libc_gets_max_chars:0xffFE

..decl_farproc:proc_gets
	//Grab the far pointer.
	astp; lb 6; sub; ca; ildb;
	rx0b; lb16; rx1b; rxlsh;
	aincr; ca; illdb; 
	rx1b; rxadd;
	//It's in RX0.
	rx3_0;
	lb0;rx2b;
	:libc_gets_looptop:
		rx0_2
		llb %libc_gets_max_chars%; rx1b
		rxcmp
		lb 0;
		cmp;
		sc %libc_gets_loopend%
		jmpifneq
		
		getchar; //Hey, user, give me some data!
		apush;
		lb 0;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;
		lb 0xd;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;
		lb 0xa;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;


		//ascii del chars.
		lb 0x7f;cmp;bpop;sc%libc_gets_handle_del%;jmpifeq;
		ab;bpush;
		lb 8;cmp;bpop;sc%libc_gets_handle_del%;jmpifeq;
		


		//greater than 126?
		ab;bpush;
		lb 126;cmp;lb2;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;

		//If This is what we do if its not a delete character.
		ab;
		rx0_3;		cbrx0;		farista;
		rx0_2;		rxincr;		rx2_0;
		rx0_3;		rxincr;		rx3_0;

		//store a space and a zero at the end of the string.
		cbrx0;		la 0;	farista;
		rx1_2;		rxsub;	
		la 0xd; putchar;
		cbrx0;
		ac;
		apush;blpush;
			proc_puts;
		pop %3%;
		la 0xd; putchar;
	:libc_gets_zero_chars:
		sc %libc_gets_looptop%;jmp;
	//Handle ascii DEL and Backspace.
	:libc_gets_handle_del:
		rx0_2; 		lb0;rx1b;	rxcmp;	sc %libc_gets_zero_chars%; jmpifeq;
		rx0_2;		rxdecr;		rx2_0;
		rx0_3;		rxdecr;		rx3_0;
		la 0xd; putchar;
		//store a space and a zero at the end of the string.
		cbrx0;		la 32;	farista;
		rxincr;		cbrx0;		la 0;	farista;
		rxdecr;
		rx1_2;		
		rxsub;	
		la 0xd; putchar;
		cbrx0;
		ac;
		apush;blpush;
			proc_puts;
		pop %3%;
		la 32; putchar;
		la 32; putchar;
		la 32; putchar;
		la 0xd; putchar;
		sc %libc_gets_looptop%;jmp;
	//ending: we must write a zero out. This actually overwrites the last character... See, we don't actually want it.
	:libc_gets_loopend:
		rx0_3;
		cbrx0; 
		la 0; 
		farista; 
farret;



//GETS_NOECHO
//Clobbers: A, B, C, RX0, RX1, RX2, RX3
..decl_farproc:proc_gets_noecho
	//Grab the far pointer.
	astp; lb 6; sub; ca; ildb;
	rx0b; lb16; rx1b; rxlsh;
	aincr; ca; illdb; 
	rx1b; rxadd;
	//It's in RX0.
	rx3_0;
	lb0;rx2b;
	:libc_gets_noecho_looptop:
		rx0_2
		llb %libc_gets_max_chars%; rx1b;
		rxcmp
		lb 0;
		cmp;
		sc %libc_gets_loopend%
		jmpifneq
		
		rx0_3;	cbrx0;
		getchar; //Hey, user, give me some data!
		farista;
		apush;
		lb 0;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;
		lb 0xd;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;
		lb 0xa;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;
		lb 126;cmp;lb2;cmp;sc%libc_gets_loopend%;jmpifeq;
		rx0_3;		rxincr;		rx3_0;
		rx0_2;		rxincr;		rx2_0;
	sc %libc_gets_noecho_looptop%;jmp;
	//We can actually share the same endings as gets, so we don't have anything here...

//WAIT~~~~~~~~~~~~
//Clobbers: A, B, C, RX0, RX1.
//RX registers go unused.
//wait_ms is in RX0.
//start_ms is in RX1.


//prototype: wait(short milliseconds)
..decl_farproc:proc_wait
	//	retrieve our argument and store it in RX0.
	astp;lb5;sub;illdaa;rx0a;
	//	store the start time in RX1
	clock;				rx1a;
	//loop.
	:libc_wait_looptop:
		//grab the time.
		clock;
		brx1;
		sub;
		ba;
		arx0;
		cmp;
		lb 2;
		cmp;
		sc %libc_wait_loopout%; jmpifneq;
		sc %libc_wait_looptop%; jmp;
	:libc_wait_loopout:
farret;


//ATOU_DEC~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//Argument is in RX0, and is returned in RX0.
//Clobbers: A,B,C,RX0,RX1,RX2,RX3
//Read a base ten integer from a string.
//Note that whitespace is *not* skipped
..decl_farproc:proc_atou_dec
	//the passed string is in RX0.
	rx3_0;
	lb 0; rx2b;					//happens to be a very fast way of transferring zero into a register.
	:libc_atou_dec_looptop:
		rx0_3; 
		cbrx0; 
		farilda;
		apush; lb 0x30; cmp; lb 0; cmp; bpop; sc %libc_atou_dec_loopout%; jmpifeq;			//Jump if the character was less than 0x30.
		ab; apush; lb 0x39; cmp; lb 2; cmp; bpop; sc %libc_atou_dec_loopout%; jmpifeq;		//Jump if the character was greater than 0x39.
		ab; lb 0x30; sub;
		rxincr;
		rx3_0;
		//the value is in A.
		rx0_2			//load the value.
		lb 10
		rx1b
		rxmul
		rx1a
		rxadd
		rx2_0			//stash it away!
		sc %libc_atou_dec_looptop%; jmp;
	:libc_atou_dec_loopout:
	rx0_2;
farret;

//ATOI_DEC~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//Argument is in RX0, and is returned in RX0.
//Clobbers: A,B,C,RX0,RX1,RX2,RX3
//Read a base ten integer from a string.
//Note that whitespace is *not* skipped


..decl_farproc:proc_atoi_dec
	//the passed string is in RX0.
		rx3_0;
		lb 0; rx2b;
	//before anything else, we need to test if the first character is NULL.
	//Notice we are using the previous function's return as our return. This is a code de-duplication.
		cbrx0; farilda; lb 0; cmp; sc %libc_atou_dec_loopout%; jmpifeq;
	//Now, we test for the presence of + and - and use those to push
		cbrx0; farilda; lb 45; cmp; sc %libc_atoi_dec_minus%; jmpifeq;
		cbrx0; farilda; lb 43; cmp; sc %libc_atoi_dec_plus%; jmpifeq;
		la 0; apush;
		sc %libc_atoi_dec_looptop%; jmp;
	:libc_atoi_dec_plus:
		la 0; apush;
		rx0_3; rxincr; rx3_0;
		sc %libc_atoi_dec_looptop%; jmp;
	:libc_atoi_dec_minus:
		la 1; apush;
		rx0_3; rxincr; rx3_0;
	:libc_atoi_dec_looptop:
		rx0_3; 
		cbrx0; 
		farilda;
		apush; lb 0x30; cmp; lb 0; cmp; bpop; sc %libc_atoi_dec_loopout%; jmpifeq;			//Jump if the character was less than 0x30.
		ab; apush; lb 0x39; cmp; lb 2; cmp; bpop; sc %libc_atoi_dec_loopout%; jmpifeq;		//Jump if the character was greater than 0x39.
		ab; lb 0x30; sub;
		rxincr;
		rx3_0;
		//the value is in A.
		rx0_2			//load the value.
		lb 10
		rx1b
		rxmul
		rx1a
		rxadd
		rx2_0			//stash it away!
		sc %libc_atoi_dec_looptop%; jmp;
	:libc_atoi_dec_loopout:
		rx0_2
		apop
		sc %libc_atoi_dec_handle_minus%; jmpifeq;
		farret;
	:libc_atoi_dec_handle_minus:
		rx0_2
		rxcompl
		rxincr
		farret

asm_end_region_restriction;
