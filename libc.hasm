

section 0x20000;asm_begin_region_restriction;
//.proc_printbytehex:sc 0,0;la 2;farcall; 
..decl_farproc:proc_printbytehex

//retrieve our argument.
	astp;lb4;sub;ca;ilda;
//push it
	apush;
	lb 4;rsh;
	lb0xf;and;
	lb 6;mul;
llb %printbytehex_jmptable_1%; add;ca;jmp;
:printbytehex_jmptable_1:
	la0x30;sc%printbytehex_jmptable_1_end%;jmp
	la0x31;sc%printbytehex_jmptable_1_end%;jmp
	la0x32;sc%printbytehex_jmptable_1_end%;jmp
	la0x33;sc%printbytehex_jmptable_1_end%;jmp
	la0x34;sc%printbytehex_jmptable_1_end%;jmp
	la0x35;sc%printbytehex_jmptable_1_end%;jmp
	la0x36;sc%printbytehex_jmptable_1_end%;jmp
	la0x37;sc%printbytehex_jmptable_1_end%;jmp
	la0x38;sc%printbytehex_jmptable_1_end%;jmp
	la0x39;sc%printbytehex_jmptable_1_end%;jmp
	la0x41;sc%printbytehex_jmptable_1_end%;jmp
	la0x42;sc%printbytehex_jmptable_1_end%;jmp
	la0x43;sc%printbytehex_jmptable_1_end%;jmp
	la0x44;sc%printbytehex_jmptable_1_end%;jmp
	la0x45;sc%printbytehex_jmptable_1_end%;jmp
	la0x46;sc%printbytehex_jmptable_1_end%;jmp
:printbytehex_jmptable_1_end:
putchar
apop;lb 15;and;lb6;mul;
llb%printbytehex_jmptable_2%;add;ca;jmp;
:printbytehex_jmptable_2:
	la0x30;sc%printbytehex_jmptable_2_end%;jmp
	la0x31;sc%printbytehex_jmptable_2_end%;jmp
	la0x32;sc%printbytehex_jmptable_2_end%;jmp
	la0x33;sc%printbytehex_jmptable_2_end%;jmp
	la0x34;sc%printbytehex_jmptable_2_end%;jmp
	la0x35;sc%printbytehex_jmptable_2_end%;jmp
	la0x36;sc%printbytehex_jmptable_2_end%;jmp
	la0x37;sc%printbytehex_jmptable_2_end%;jmp
	la0x38;sc%printbytehex_jmptable_2_end%;jmp
	la0x39;sc%printbytehex_jmptable_2_end%;jmp
	la0x41;sc%printbytehex_jmptable_2_end%;jmp
	la0x42;sc%printbytehex_jmptable_2_end%;jmp
	la0x43;sc%printbytehex_jmptable_2_end%;jmp
	la0x44;sc%printbytehex_jmptable_2_end%;jmp
	la0x45;sc%printbytehex_jmptable_2_end%;jmp
	la0x46;sc%printbytehex_jmptable_2_end%;jmp
:printbytehex_jmptable_2_end:
putchar;
farret;


//.proc_puts:sc%@%;la2;farcall;
..decl_farproc:proc_puts
//move the stack pointer back.
astp;lb6;sub;
illdaa;lb8;rsh;lb255;and;ca;
//load the thing thats there. But we also loaded the high byte of the
//next short, so we need to get rid of that. Goes in C
astp;lb5;sub;illdaa;//we need to grab that short.

//we now have our far pointer! put it on the top of the stack for easy access.
//we actually push 4 bytes, so we can rx0pop.
lb0;bpush;bc;bpush;alpush;
:puts_looptop:
	//setup far pointer.
	rx0pop;		rx0push;	cbrx0;
	//load through far pointer and print
	farilda;		putchar;
	//if the character was zero, jump to the end of the loop
	lb0;cmp;sc%puts_loopend%;jmpifeq;
	//else, increment
	rx0pop;rxincr;rx0push;
sc %puts_looptop%;jmp;
:puts_loopend:
blpop;blpop;
farret;

//WAIT~~~~~~~~~~~~

//variable used for waiting thousandths of a second.
.libc_ld_wait_ms:farllda %&@%;
.libc_st_wait_ms:farstla %&@%;
nop;nop;

.libc_ld_start_ms_b:farlldb %&@%;
.libc_ld_start_ms_a:farllda %&@%;
.libc_st_start_ms_b:farstlb %&@%;
.libc_st_start_ms_a:farstla %&@%;
nop;nop;
//prototype: wait(short milliseconds)
..decl_farproc:proc_wait
	//	retrieve our argument and store it in the desginated spot.
	astp;lb5;sub;illdaa;libc_st_wait_ms;
	//	store the start time.
	clock;libc_st_start_ms_a;
	//loop.
	:libc_wait_looptop:
		//grab the time.
		clock;
		libc_ld_start_ms_b;
		sub;
		ba;
		libc_ld_wait_ms;
		cmp;
		lb 2;
		cmp;
		sc %libc_wait_loopout%; jmpifneq;
		sc %libc_wait_looptop%; jmp;
	:libc_wait_loopout:
farret;

asm_end_region_restriction;
