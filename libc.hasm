

section 0x20000;asm_begin_region_restriction;

//.proc_printbytehex:sc 0,0;la 2;farcall; 

..decl_farproc:proc_printbytehex
//retrieve our argument.
	astp;lb4;sub;ca;ilda;
//push it
	apush;
	lb 4;rsh;
	lb0xf;and;
	lb 6;mul;
llb %libc_printbytehex_jmptable_1%; add;ca;jmp;
:libc_printbytehex_jmptable_1:
	la0x30;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x31;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x32;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x33;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x34;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x35;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x36;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x37;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x38;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x39;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x41;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x42;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x43;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x44;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x45;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x46;sc%libc_printbytehex_jmptable_1_end%;jmp
:libc_printbytehex_jmptable_1_end:
putchar
apop;lb 15;and;lb6;mul;
llb%libc_printbytehex_jmptable_2%;add;ca;jmp;
:libc_printbytehex_jmptable_2:
	la0x30;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x31;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x32;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x33;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x34;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x35;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x36;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x37;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x38;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x39;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x41;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x42;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x43;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x44;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x45;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x46;sc%libc_printbytehex_jmptable_2_end%;jmp
:libc_printbytehex_jmptable_2_end:
putchar;
farret;


//PUTS~~~~~~~~~~~~~~~
//CLOBBERS: A, B, C, RX0
..decl_farproc:proc_puts
	//fetch the high byte of a three byte pointer.
	astp;lb6;sub;ca;
	ilda;ca;
	//load the thing thats there. But we also loaded the high byte of the
	//next short, so we need to get rid of that. Goes in C
	astp;lb5;sub;illdaa;//we need to grab that short.
	//we now have our far pointer! put it on the top of the stack for easy access.
	//we actually push 4 bytes, so we can rx0pop.
	lb0;bpush;bc;bpush;alpush;
	:libc_puts_looptop:
		//setup far pointer.
		rx0pop;		push %4%;	cbrx0;
		//load through far pointer and print
		farilda;
		apush;
		//if the character was zero, jump to the end of the loop
		//also make sure to pop the character from the stack, so we can print it later.
		lb0;cmp;bpop;sc%libc_puts_loopend%;jmpifeq;
		//else, print and increment
		ab
		putchar
		rx0pop;		rxincr;		rx0push;
	sc %libc_puts_looptop%;jmp;
	:libc_puts_loopend:
	blpop;blpop;
farret;


//STRLEN~~~~~~~~~~~~~~~~~~~~~~
//Clobbers: A, B, C, RX0
..decl_farproc:proc_strlen
	//fetch far pointer.
	astp;lb6;sub;ca;
	ilda;ca;
	astp;lb5;sub;illdaa;//get the short!
	//stash away RX2
	rx2push;
	//we now have our far pointer! put it on the top of the stack for easy access.
	//we actually push 4 bytes, so we can rx0pop.
	lb0;bpush;bc;bpush;alpush;
	lrx2 %/0%;
	:libc_strlen_looptop:
		rx0pop;		push %4%;	cbrx0;
		farilda;
		lb0;cmp;	sc%libc_strlen_loopend%;jmpifeq;
		rx0pop;		rxincr;		rx0push;
		rx0_2;		rxincr;		rx2_0;
	sc %libc_strlen_looptop%;jmp;
	:libc_strlen_loopend:
	blpop;blpop;
	rx0_2;		//move RX2 to RX0 so we can keep it.
	rx2pop;		//restore RX2.
	astp;lb5;sub;ca;
	//get the low 16 bits.
	arx0; istla;
	rx1push; lrx1 %/16%; rxrsh;rx1pop;
	astp;lb6;sub;ca;
	arx0; ista;
farret;

//GETS
//Clobbers: A, B, C, RX0
..decl_farproc:proc_gets
	//fetch far pointer.
	astp;lb6;sub;ca;
	ilda;ca;
	astp;lb5;sub;illdaa;//get the short!
	//we now have our far pointer! put it on the top of the stack for easy access.
	//we actually push 4 bytes, so we can rx0pop.
	lb0;bpush;bc;bpush;alpush;
	lrx2 %/0%;
	:libc_gets_looptop:
		getchar; //Hey, user, give me some data!
		//First, is it zero?
		apush;
		lb 0;cmp;bpop;sc%libc_gets_onlypop_end%;jmpifeq;
		ab;bpush;
		lb 32;cmp;lb0;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;
		lb 126;cmp;lb2;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;
		//write it out!
		rx0pop;		push %4%;	cbrx0;		farista;
		//echo the character out so the user can see it.
		putchar;
		rx0pop;		rxincr;		rx0push;
		sc %libc_gets_looptop%;jmp;
	//ending 1: we must write a zero out. This actually overwrites the last character... See, we don't actually want it.
	:libc_gets_loopend:
		rx0pop; 
		cbrx0; 
		la 0; 
		farista; 
		farret;
	//ending 2: the last character was null
	:libc_gets_onlypop_end:
		rx0pop;
		farret;



//GETS_NOECHO
//Clobbers: A, B, C, RX0
..decl_farproc:proc_gets_noecho
	//fetch far pointer.
	astp;lb6;sub;ca;
	ilda;ca;
	astp;lb5;sub;illdaa;//get the short!
	//we now have our far pointer! put it on the top of the stack for easy access.
	//we actually push 4 bytes, so we can rx0pop.
	lb0;bpush;bc;bpush;alpush;
	lrx2 %/0%;
	:libc_gets_noecho_looptop:
		rx0pop;		push %4%;	cbrx0;
		getchar; //Hey, user, give me some data!
		farista;
		//begin the process of checking values. 0, <30, and >126.
		apush;
		lb 0;cmp;bpop;sc%libc_gets_onlypop_end%;jmpifeq;
		ab;bpush;
		lb 32;cmp;lb0;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;
		lb 126;cmp;lb2;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		rx0pop;		rxincr;		rx0push;
	sc %libc_gets_noecho_looptop%;jmp;
	//We can actually share the same endings as gets, so we don't have anything here...
halt;

//WAIT~~~~~~~~~~~~

//variable used for waiting thousandths of a second.
.libc_ld_wait_ms:farllda %&@%;
.libc_st_wait_ms:farstla %&@%;
nop;nop;
//variable used for storing the start num of milliseconds.
.libc_ld_start_ms_b:farlldb %&@%;
.libc_ld_start_ms_a:farllda %&@%;
.libc_st_start_ms_b:farstlb %&@%;
.libc_st_start_ms_a:farstla %&@%;
nop;nop;
//prototype: wait(short milliseconds)
..decl_farproc:proc_wait
	//	retrieve our argument and store it in the desginated spot.
	astp;lb5;sub;illdaa;libc_st_wait_ms;
	//	store the start time.
	clock;libc_st_start_ms_a;
	//loop.
	:libc_wait_looptop:
		//grab the time.
		clock;
		libc_ld_start_ms_b;
		sub;
		ba;
		libc_ld_wait_ms;
		cmp;
		lb 2;
		cmp;
		sc %libc_wait_loopout%; jmpifneq;
		sc %libc_wait_looptop%; jmp;
	:libc_wait_loopout:
farret;

asm_end_region_restriction;
