

section 0x20000;asm_begin_region_restriction;
//.proc_printbytehex:sc 0,0;la 2;farcall; 
..decl_farproc:proc_printbytehex
//retrieve our argument.
	astp;lb4;sub;ca;ilda;
//push it
	apush;
	lb 4;rsh;
	lb0xf;and;
	lb 6;mul;
llb %printbytehex_jmptable_1%; add;ca;jmp;
:printbytehex_jmptable_1:
	la0x30;sc%printbytehex_jmptable_1_end%;jmp
	la0x31;sc%printbytehex_jmptable_1_end%;jmp
	la0x32;sc%printbytehex_jmptable_1_end%;jmp
	la0x33;sc%printbytehex_jmptable_1_end%;jmp
	la0x34;sc%printbytehex_jmptable_1_end%;jmp
	la0x35;sc%printbytehex_jmptable_1_end%;jmp
	la0x36;sc%printbytehex_jmptable_1_end%;jmp
	la0x37;sc%printbytehex_jmptable_1_end%;jmp
	la0x38;sc%printbytehex_jmptable_1_end%;jmp
	la0x39;sc%printbytehex_jmptable_1_end%;jmp
	la0x41;sc%printbytehex_jmptable_1_end%;jmp
	la0x42;sc%printbytehex_jmptable_1_end%;jmp
	la0x43;sc%printbytehex_jmptable_1_end%;jmp
	la0x44;sc%printbytehex_jmptable_1_end%;jmp
	la0x45;sc%printbytehex_jmptable_1_end%;jmp
	la0x46;sc%printbytehex_jmptable_1_end%;jmp
:printbytehex_jmptable_1_end:
putchar
apop;lb 15;and;lb6;mul;
llb%printbytehex_jmptable_2%;add;ca;jmp;
:printbytehex_jmptable_2:
	la0x30;sc%printbytehex_jmptable_2_end%;jmp
	la0x31;sc%printbytehex_jmptable_2_end%;jmp
	la0x32;sc%printbytehex_jmptable_2_end%;jmp
	la0x33;sc%printbytehex_jmptable_2_end%;jmp
	la0x34;sc%printbytehex_jmptable_2_end%;jmp
	la0x35;sc%printbytehex_jmptable_2_end%;jmp
	la0x36;sc%printbytehex_jmptable_2_end%;jmp
	la0x37;sc%printbytehex_jmptable_2_end%;jmp
	la0x38;sc%printbytehex_jmptable_2_end%;jmp
	la0x39;sc%printbytehex_jmptable_2_end%;jmp
	la0x41;sc%printbytehex_jmptable_2_end%;jmp
	la0x42;sc%printbytehex_jmptable_2_end%;jmp
	la0x43;sc%printbytehex_jmptable_2_end%;jmp
	la0x44;sc%printbytehex_jmptable_2_end%;jmp
	la0x45;sc%printbytehex_jmptable_2_end%;jmp
	la0x46;sc%printbytehex_jmptable_2_end%;jmp
:printbytehex_jmptable_2_end:
putchar;
farret;



..decl_farproc:proc_puts
	//fetch the high byte of a three byte pointer.
	astp;lb6;sub;ca;
	ilda;ca;
	//load the thing thats there. But we also loaded the high byte of the
	//next short, so we need to get rid of that. Goes in C
	astp;lb5;sub;illdaa;//we need to grab that short.
	//we now have our far pointer! put it on the top of the stack for easy access.
	//we actually push 4 bytes, so we can rx0pop.
	lb0;bpush;bc;bpush;alpush;
	:puts_looptop:
		//setup far pointer.
		rx0pop;		push %4%;	cbrx0;
		//load through far pointer and print
		farilda;
		apush;
		//if the character was zero, jump to the end of the loop
		//also make sure to pop the character from the stack, so we can print it later.
		lb0;cmp;bpop;sc%puts_loopend%;jmpifeq;
		//else, print and increment
		ab
		putchar
		rx0pop;		rxincr;		rx0push;
	sc %puts_looptop%;jmp;
	:puts_loopend:
	blpop;blpop;
farret;

//STRLEN~~~~~~~~~~~~~~~~~~~~~~
..decl_farproc:proc_strlen
	//fetch far pointer.
	astp;lb6;sub;ca;
	ilda;ca;
	astp;lb5;sub;illdaa;//get the short!
	//stash away RX2
	rx2push;
	//we now have our far pointer! put it on the top of the stack for easy access.
	//we actually push 4 bytes, so we can rx0pop.
	lb0;bpush;bc;bpush;alpush;
	lrx2 %/0%;
	:strlen_looptop:
		rx0pop;		push %4%;	cbrx0;
		farilda;
		lb0;cmp;	sc%strlen_loopend%;jmpifeq;
		rx0pop;		rxincr;		rx0push;
		rx0_2;		rxincr;		rx2_0;
	sc %strlen_looptop%;jmp;
	:strlen_loopend:
	blpop;blpop;
	rx2pop;		//restore RX2.
	rx0_2
	astp;lb5;sub;ca;
	//get the low 16 bits.
	arx0; istla;
	rx1push; lrx1 %/16%; rxrsh;rx1pop;
	astp;lb6;sub;ca;
	arx0; ista;
farret;

//WAIT~~~~~~~~~~~~

//variable used for waiting thousandths of a second.
.libc_ld_wait_ms:farllda %&@%;
.libc_st_wait_ms:farstla %&@%;
nop;nop;
//variable used for storing the start num of milliseconds.
.libc_ld_start_ms_b:farlldb %&@%;
.libc_ld_start_ms_a:farllda %&@%;
.libc_st_start_ms_b:farstlb %&@%;
.libc_st_start_ms_a:farstla %&@%;
nop;nop;
//prototype: wait(short milliseconds)
..decl_farproc:proc_wait
	//	retrieve our argument and store it in the desginated spot.
	astp;lb5;sub;illdaa;libc_st_wait_ms;
	//	store the start time.
	clock;libc_st_start_ms_a;
	//loop.
	:libc_wait_looptop:
		//grab the time.
		clock;
		libc_ld_start_ms_b;
		sub;
		ba;
		libc_ld_wait_ms;
		cmp;
		lb 2;
		cmp;
		sc %libc_wait_loopout%; jmpifneq;
		sc %libc_wait_looptop%; jmp;
	:libc_wait_loopout:
farret;

asm_end_region_restriction;
