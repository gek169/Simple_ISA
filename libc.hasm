

section 0x20000;asm_begin_region_restriction;
.proc_printbytehex:sc 0,0;la 2;farcall; 
//retrieve our argument.
	astp;lb4;sub;ca;ilda;
//push it
	apush;
	lb 4;rsh;
	lb0xf;and;
	lb 7;mul;
llb %printbytehex_jmptable_1%; add;ca;jmp;
:printbytehex_jmptable_1:
	la0x30;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x31;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x32;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x33;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x34;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x35;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x36;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x37;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x38;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x39;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x41;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x42;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x43;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x44;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x45;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x46;putchar;sc%printbytehex_jmptable_1_end%;jmp
:printbytehex_jmptable_1_end:
apop;lb 15;and;lb7;mul;
llb%printbytehex_jmptable_2%;add;ca;jmp;
:printbytehex_jmptable_2:
	la0x30;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x31;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x32;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x33;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x34;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x35;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x36;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x37;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x38;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x39;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x41;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x42;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x43;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x44;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x45;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x46;putchar;sc%printbytehex_jmptable_2_end%;jmp
:printbytehex_jmptable_2_end:
farret;


.proc_puts:sc%@%;la2;farcall;
//move the stack pointer back.
astp;lb6;sub;
illdaa;lb8;rsh;lb255;and;ca;
//load the thing thats there. But we also loaded the high byte of the
//next short, so we need to get rid of that. Goes in C
astp;lb5;sub;illdaa;//we need to grab that short.

//we now have our far pointer! put it on the top of the stack for easy access.
//we actually push 4 bytes, so we can rx0pop.
lb0;bpush;bc;bpush;alpush;
:puts_looptop:
	//setup far pointer.
	rx0pop;		rx0push;	cbrx0;
	//load through far pointer and print
	farilda;		putchar;
	//if the character was zero, jump to the end of the loop
	lb0;cmp;sc%puts_loopend%;jmpifeq;
	//else, increment
	rx0pop;rxincr;rx0push;
sc %puts_looptop%;jmp;
:puts_loopend:
blpop;blpop;
farret;

//WAIT~~~~~~~~~~~~
//variable used for waiting thousandths of a second.
.libc_ld_wait_ms:sc%0x2%;llb %@%;farillda;
.libc_st_wait_ms:sc%0x2%;llb %@%;faristla;
//storage for that variable
nop;nop;
//prototype: wait(short milliseconds)
//for very small values it may erroneously wait a long time.
.proc_wait:sc%@%;la2;farcall;
	//retrieve our argument and store it in the desginated spot.
	astp;
	lb5;
	sub;
	illdaa;
	libc_st_wait_ms;
	//calculate the target time to stop at.
	clock;
	alpush;
		libc_ld_wait_ms;
	blpop;
	add;
	libc_st_wait_ms;
	:wait_looptop:
	clock;
	alpush;
		libc_ld_wait_ms;
	blpop;
	cmp;
	sc %wait_looptop%;
	jmpifneq;
farret;

asm_end_region_restriction;
