//	SISA16 "LIBC" STANDARD LIBRARY
// Intended to fit in a single region.
// (C) David M.H.S. Webster 2021
// Written for the Public Domain.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~Let all that you do be done with love~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

section 0x20000;asm_begin_region_restriction;
..decl_farproc:proc_printbytehex
//retrieve our argument.
	astp;lb4;sub;ca;ilda;
//push it
	apush;
	lb 4;rsh;
	lb0xf;and;
	lb 6;mul;
llb %libc_printbytehex_jmptable_1%; add;ca;jmp;
:libc_printbytehex_jmptable_1:
	la0x30;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x31;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x32;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x33;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x34;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x35;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x36;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x37;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x38;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x39;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x41;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x42;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x43;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x44;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x45;sc%libc_printbytehex_jmptable_1_end%;jmp
	la0x46;sc%libc_printbytehex_jmptable_1_end%;jmp
:libc_printbytehex_jmptable_1_end:
putchar
apop;lb 15;and;lb6;mul;
llb%libc_printbytehex_jmptable_2%;add;ca;jmp;
:libc_printbytehex_jmptable_2:
	la0x30;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x31;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x32;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x33;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x34;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x35;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x36;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x37;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x38;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x39;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x41;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x42;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x43;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x44;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x45;sc%libc_printbytehex_jmptable_2_end%;jmp
	la0x46;sc%libc_printbytehex_jmptable_2_end%;jmp
:libc_printbytehex_jmptable_2_end:
putchar;
farret;


//PUTS~~~~~~~~~~~~~~~
//CLOBBERS: A, B, C, RX0, RX1
..decl_farproc:proc_puts
	//Grab the far pointer.
	astp; lb 6; sub; ca; ildb;
	rx0b; lrx1 %/16%; rxlsh;
	aincr; ca; illdb; 
	rx1b; rxadd;
	:libc_puts_looptop:
		cbrx0;
		farilda;
		apush;
		lb0;cmp;bpop;sc%libc_puts_loopend%;jmpifeq;
		ab
		putchar
		rxincr;
	sc %libc_puts_looptop%;jmp;
	:libc_puts_loopend:
farret;


//STRLEN~~~~~~~~~~~~~~~~~~~~~~
//Clobbers: A, B, C, RX0, RX1, RX2
..decl_farproc:proc_strlen
	//Grab the far pointer.
	astp; lb 6; sub; ca; ildb;
	rx0b; lrx1 %/16%; rxlsh;
	aincr; ca; illdb; 
	rx1b; rxadd;
	//It's in RX0.
	//we now have our far pointer! put it on the top of the stack for easy access.
	//we actually push 4 bytes, so we can rx0pop.
	rx1_0;
	lrx2 %/0%;
	:libc_strlen_looptop:
		rx0_1;	cbrx0;
		farilda;
		lb0;		cmp;	sc%libc_strlen_loopend%;	jmpifeq;
		rxincr;		rx1_0;
		rx0_2;		rxincr;		rx2_0;
		sc %libc_strlen_looptop%;jmp;
	:libc_strlen_loopend:
		rx0_2;								//move RX2 to RX0 so we can keep it.
		astp;lb5;sub;ca;
		arx0; istla							//get the low 16 bits.
		lrx1 %/16%
		rxrsh
		astp;lb6;sub;ca;
		arx0; ista;
farret;

//MEMCPY~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//Clobbers: A,B,C, RX0, RX1, RX2, RX3.
//RETURNS: Nothing.
//ARGS:
//src: RX1
//dest: RX0
//bytes: RX2
.libc_mcpy_src:@
halt;halt;
halt;halt;

..decl_farproc:proc_memcpy
	rx3_0;
	farstrx1 %&libc_mcpy_src%;
	lrx1 %/0%;
	:libc_mcpy_looptop:
		//Quit? if not, decrement.
		rx0_2 
		rxcmp
		sc %libc_mcpy_loopend%; jmpifeq;
		rxdecr
		rx2_0
		
		//load a single byte.
		farldrx0 %&   libc_mcpy_src%
		cbrx0
		farilda
		rxincr
		farstrx0 %&   libc_mcpy_src%
		//store that single byte.
		rx0_3
			cbrx0
			farista
			rxincr
		rx3_0
		sc %libc_mcpy_looptop%; jmp;
	:libc_mcpy_loopend:
	farret;

//GETS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//Clobbers: A, B, C, RX0, RX1, RX2.
//Designed for interactive mode.
//Limit of 0xffFE characters.
.libc_gets_max_chars:0xffFE

..decl_farproc:proc_gets
	//fetch far pointer.
	astp;lb6;sub;ca;
	ilda;ca;
	astp;lb5;sub;illdaa;//get the short!
	lrx2 %/0%;
	//we now have our far pointer! put it on the top of the stack for easy access.
	//we actually push 4 bytes, so we can rx0pop.
	lb0;bpush;bc;bpush;alpush;
	lrx2 %/0%;
	:libc_gets_looptop:
		rx0_2
		lrx1 %/libc_gets_max_chars%
		rxcmp
		lb 0;
		cmp;
		sc %libc_gets_loopend%
		jmpifneq
		
		getchar; //Hey, user, give me some data!
		apush;
		lb 0;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;
		lb 0xd;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;
		lb 0xa;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;


		//ascii del chars.
		lb 0x7f;cmp;bpop;sc%libc_gets_handle_del%;jmpifeq;
		ab;bpush;
		lb 8;cmp;bpop;sc%libc_gets_handle_del%;jmpifeq;
		


		//greater than 126?
		ab;bpush;
		lb 126;cmp;lb2;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;

		//If This is what we do if its not a delete character.
		ab;
		rx0pop;		push %4%;	cbrx0;		farista;
		rx0_2;		rxincr;		rx2_0;
		rx0pop;		rxincr;		rx0push;

		//store a space and a zero at the end of the string.
		cbrx0;		la 0;	farista;
		rx1_2;		rxsub;	
		la 0xd; putchar;
		cbrx0;
		ac;
		apush;blpush;
			proc_puts;
		pop %3%;
		la 0xd; putchar;
	:libc_gets_zero_chars:
		sc %libc_gets_looptop%;jmp;
	//Handle ascii DEL and Backspace.
	:libc_gets_handle_del:
		rx0_2; 		lrx1 %/0%; 	rxcmp; sc %libc_gets_zero_chars%; jmpifeq;
		rx0_2;		rxdecr;		rx2_0;
		rx0pop;		rxdecr;		rx0push;
		la 0xd; putchar;
		//store a space and a zero at the end of the string.
		cbrx0;		la 32;	farista;
		rxincr;		cbrx0;		la 0;	farista;
		rxdecr;
		rx1_2;		rxsub;	
		la 0xd; putchar;
		cbrx0;
		ac;
		apush;blpush;
			proc_puts;
		pop %3%;
		la 32; putchar;
		la 32; putchar;
		la 32; putchar;
		la 0xd; putchar;
		sc %libc_gets_looptop%;jmp;
	//ending: we must write a zero out. This actually overwrites the last character... See, we don't actually want it.
	:libc_gets_loopend:
		rx0pop; 
		cbrx0; 
		la 0; 
		farista; 
		farret;



//GETS_NOECHO
//Clobbers: A, B, C, RX0
..decl_farproc:proc_gets_noecho
	//fetch far pointer.
	astp;lb6;sub;ca;
	ilda;ca;
	astp;lb5;sub;illdaa;//get the short!
	//we now have our far pointer! put it on the top of the stack for easy access.
	//we actually push 4 bytes, so we can rx0pop.
	lb0;bpush;bc;bpush;alpush;
	:libc_gets_noecho_looptop:
		rx0_2
		lrx1 %/libc_gets_max_chars%
		rxcmp
		lb 0;
		cmp;
		sc %libc_gets_loopend%
		jmpifneq
		
		rx0pop;		push %4%;	cbrx0;
		getchar; //Hey, user, give me some data!
		farista;
		apush;
		lb 0;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;
		lb 0xd;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;bpush;
		lb 0xa;cmp;bpop;sc%libc_gets_loopend%;jmpifeq;
		ab;
		lb 126;cmp;lb2;cmp;sc%libc_gets_loopend%;jmpifeq;
		rx0pop;		rxincr;		rx0push;
		rx0_2;		rxincr;		rx2_0;
	sc %libc_gets_noecho_looptop%;jmp;
	//We can actually share the same endings as gets, so we don't have anything here...

//WAIT~~~~~~~~~~~~

//variable used for waiting thousandths of a second.
.libc_ld_wait_ms:farllda %&@%;
.libc_st_wait_ms:farstla %&@%;
nop;nop;
//variable used for storing the start num of milliseconds.
.libc_ld_start_ms_b:farlldb %&@%;
.libc_ld_start_ms_a:farllda %&@%;
.libc_st_start_ms_b:farstlb %&@%;
.libc_st_start_ms_a:farstla %&@%;
nop;nop;
//prototype: wait(short milliseconds)
..decl_farproc:proc_wait
	//	retrieve our argument and store it in the desginated spot.
	astp;lb5;sub;illdaa;libc_st_wait_ms;
	//	store the start time.
	clock;libc_st_start_ms_a;
	//loop.
	:libc_wait_looptop:
		//grab the time.
		clock;
		libc_ld_start_ms_b;
		sub;
		ba;
		libc_ld_wait_ms;
		cmp;
		lb 2;
		cmp;
		sc %libc_wait_loopout%; jmpifneq;
		sc %libc_wait_looptop%; jmp;
	:libc_wait_loopout:
farret;

asm_end_region_restriction;
