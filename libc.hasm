

section 0x20000;asm_begin_region_restriction;
//.proc_printbytehex:sc 0,0;la 2;farcall; 
..decl_farproc:proc_printbytehex

//retrieve our argument.
	astp;lb4;sub;ca;ilda;
//push it
	apush;
	lb 4;rsh;
	lb0xf;and;
	lb 7;mul;
llb %printbytehex_jmptable_1%; add;ca;jmp;
:printbytehex_jmptable_1:
	la0x30;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x31;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x32;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x33;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x34;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x35;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x36;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x37;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x38;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x39;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x41;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x42;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x43;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x44;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x45;putchar;sc%printbytehex_jmptable_1_end%;jmp
	la0x46;putchar;sc%printbytehex_jmptable_1_end%;jmp
:printbytehex_jmptable_1_end:
apop;lb 15;and;lb7;mul;
llb%printbytehex_jmptable_2%;add;ca;jmp;
:printbytehex_jmptable_2:
	la0x30;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x31;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x32;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x33;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x34;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x35;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x36;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x37;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x38;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x39;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x41;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x42;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x43;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x44;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x45;putchar;sc%printbytehex_jmptable_2_end%;jmp
	la0x46;putchar;sc%printbytehex_jmptable_2_end%;jmp
:printbytehex_jmptable_2_end:
farret;


//.proc_puts:sc%@%;la2;farcall;
..decl_farproc:proc_puts
//move the stack pointer back.
astp;lb6;sub;
illdaa;lb8;rsh;lb255;and;ca;
//load the thing thats there. But we also loaded the high byte of the
//next short, so we need to get rid of that. Goes in C
astp;lb5;sub;illdaa;//we need to grab that short.

//we now have our far pointer! put it on the top of the stack for easy access.
//we actually push 4 bytes, so we can rx0pop.
lb0;bpush;bc;bpush;alpush;
:puts_looptop:
	//setup far pointer.
	rx0pop;		rx0push;	cbrx0;
	//load through far pointer and print
	farilda;		putchar;
	//if the character was zero, jump to the end of the loop
	lb0;cmp;sc%puts_loopend%;jmpifeq;
	//else, increment
	rx0pop;rxincr;rx0push;
sc %puts_looptop%;jmp;
:puts_loopend:
blpop;blpop;
farret;

//WAIT~~~~~~~~~~~~

//variable used for waiting thousandths of a second.
.libc_ld_wait_ms:farllda %&@%;
.libc_st_wait_ms:farstla %&@%;
nop;nop;

//prototype: wait(short milliseconds)

..decl_farproc:proc_wait
	//retrieve our argument and store it in the desginated spot.
	astp;
	lb5;
	sub;
	illdaa;
	libc_st_wait_ms;
	//calculate the target time to stop at.
	clock;
	ba;
	libc_ld_wait_ms;
	add;
	libc_st_wait_ms;
	rx3push;rx3b;
	cmp;lb2;cmp;
	sc %libc_wait_normal_looptop%;jmpifeq;
	sc %libc_wait_special_looptop%;jmp;
	:libc_wait_normal_looptop:
			clock;
			ba;
			//is less than the time?
			libc_ld_wait_ms;cmp;lb0;cmp
			sc %libc_wait_loopend%;jmpifeq;
			//is not equal to time?
			//fallthrough:
			sc %libc_wait_normal_looptop%;jmp;
	:libc_wait_special_looptop:
			clock;
			ba;
			//equal to time?
			libc_ld_wait_ms;cmp;
			sc %libc_wait_loopend%;jmpifeq;
			//less than end time + 1 second?
			libc_ld_wait_ms;
			rx3b;
			llb%1000%;add;cmp;lb0;cmp;
			brx3;
			sc %libc_wait_loopend%;jmpifeq;
			sc %libc_wait_special_looptop%;jmp;
	:libc_wait_loopend:
	rx3pop;
farret;

asm_end_region_restriction;
