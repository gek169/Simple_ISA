Simple instruction set architecture for an 16-bit, micro-like computer.

The C source is obfuscated but the C++ is not and runs at compiletime

The included program, program.bin, is designed for the obfuscated C emulator.

The included makefiles and shell script how to use the emulator and its associated tools.

The emulator and assembler are confirmed to compile with Tiny C, Clang, and GCC on Linux and the included program
works.

The emulator itself is C89 compliant, but the assembler uses C99 due to it using "unsigned long long".

It could be converted to C89 as well but it would require re-writing my string library.

It it is a simple program which increments the value at memory location 488 (1e8) until it is equal to 99.

These are the supported instructions in the C version, the C++ has slightly fewer:

halt- end execution (1 byte) (0)
lda- load byte into register a,zero extend (3 bytes)(1)
la - set register a to value (2 bytes) (2)
ldb - load byte into register b, zero extend (3 bytes)(3)
lb - set register b to value (2 bytes) (4)
sc- load 2 constant bytes into c (3 bytes) (5)
sta- store a to location (3 bytes) (6)
stb- store b to location (3 bytes) (7)
add- a = a + b (1 byte) (8)
sub- a = a - b (1 byte) (9)
mul- a = a * b (1 byte) (A)
div- a = a / b (1 byte) (B)
mod- a = a % b (1 byte) (C)
cmp- if(a<b) a = 0; else if(a>b)a=2; else a=1; (1 byte) (D)
jmpifeq- set program counter to c if a == 1 (1 byte) (E)
jmpifneq- set program counter to c if a is not 1 (1  byte) (F)
getchar- read single byte from stdin into register A (1 byte) (10)
putchar- Write register A to standard out. (1 byte)(11)
and- a = a & b (1 byte)(12)
or- a = a | b (1 byte)(13)
xor- a = a ^ b (1 byte)(14)
lsh- a <<= b&7 (1 byte)(15)
rsh- a >>= b&7 (1 byte)(16)
ilda- a = read(c), indirectly access memory through register c and load it into a (1 byte)(17)
ildb- b = read(c), indirectly access memory through register c and load it into b (1 byte)(18)
cab- c = a<<8 + b, make c the combination of a and b. (1 byte)(19)
ab- a = b (1 byte)(1A)
ba- b = a (1 byte)(1B)
alc- a = low half of c (1 byte)(1C)
ahc- a = the high half of c (1 byte)(1D)
nop- (1byte) (1E)
cba a = c = b<<8 + a, make c the other combination of a and b. (1 byte) (1F)
~~~~~~~~
Special 16 bit opcodes specifically for 16 bit mode.
~~~~~~~~
lla, Large Load 2 constant bytes into A (3 bytes)(20)
illda, a = [c], indirectly load 2 bytes into A through C (1 byte)(21)
llb, Large Load 2 constant bytes into B (3 bytes)(22)
illdb b = [c], indirectly load 2 bytes int B through C (1 byte)(23)
illdaa indirectly load 2 bytes into A through A (1 byte)(24)
illdbb indirectly load 2 bytes into B through B (1 byte)(25)
illdab indirectly load 2 bytes into A through B (1 byte)(26)
illdba indirectly load 2 bytes into B through A (1 byte)(27)
ca c=a (1 byte)(28)
cb c=b (1 byte)(29)
ac a=c (1 byte)(2A)
bc b=c (1 byte)(2B)

There are plenty of free instruction spots for you to play around with in your experimentation.

The primary usecase for this is probably embedding a portable bytecode instruction set into a game,
or for educational purposes.

Indirect memory addressing can be done by doing math in the A and B registers and moving the result to C,
if you want to stick to "8 bit mode" which is what the C++ implementation has.

in the C code, all the registers are 16 bit, and there are direct register-to-register moves,
so you don't have to use memory if you don't want to.

The emulator will print out its memory layout at the end of execution if you pass an additional argument
to it on the commandline.

The emulator requires a filename as the first parameter.

A very basic assembler is included with the ability to define sections, 
include arbitrary data,
and write your own multi-statement macros.
It also does a limited amount of error checking.

~~DMHSW~~

