".TH 1\n"
".SH sisa16_asm\n"
"Macro-enabled Assembler and Disassembler for the sisa16 virtual portable computer architecture.\n"
".SH SYNOPSIS\n"
".B sisa16_asm\n"
".B -i [or -run]\n"
".B -dis\n"
".B -fdis\n"
".IR infilename\n"
".IR location\n"
".B -o \n"
".IR outfilename\n"
".B [-DBG]\n"
".B [-nc]\n"
".B [--no-comments]\n"
".B [-C]\n"
".B [-E]\n"
".B [-pl]\n"
".B [-v]\n"
".B [-h]\n"
".B [--help]\n"
".B [--version]\n"
".SH DESCRIPTION\n"
".B sisa16_asm\n"
"builds and optionally executes SISA16 virtual machine images. for the\n"
".B sisa16\n"
"virtual portable computer architecture.\n"
"\n"
".SH YOUR MANPAGE SUCKS\n"
"\n"
"Assembling a file:\n"
"\n"
"sisa16_asm -i my_program.asm -o my_program.bin\n"
"\n"
"Assembling and running a file, without creating a bin:\n"
"\n"
"sisa16_asm -run my_program.asm\n"
"\n"
"Displaying compiletime environment information:\n"
"\n"
"sisa16_asm -C\n"
"\n"
"Viewing version information:\n"
"\n"
"sisa16_asm -v\n"
"\n"
".SH OPTIONS\n"
".BR -i\n"
"specifies the imput assembly file. The last input file is used, no others are.\n"
"\n"
"sisa16_asm -i myfile.asm -o myfile.bin\n"
"\n"
".BR -run\n"
"No output file is generated. An emulator built into the assembler is used to immediately execute code, making this an effective scripting language.\n"
"\n"
"sisa16_asm -run myfile.asm\n"
"\n"
".BR -dis\n"
"Specifies a file to diassemble.\n"
"\n"
"sisa16_asm -dis clock.bin 0x20000\n"
"\n"
"will disassemble continuously starting from 0x20000 (the third region) until three halts or illegal opcodes are found.\n"
"\n"
"you can also use --disassemble\n"
"\n"
".BR -fdis\n"
"Specifies a file to disassemble, but does not block on excess illegal opcodes. The entire image is disassembled.\n"
"\n"
"sisa16_asm -fdis clock.bin 0x20000\n"
"\n"
".BR -o\n"
"specifies the output filename.\n"
"\n"
".BR -DBG\n"
"Enables debug output from the assembler\n"
"\n"
".BR -nc\n"
"Disable comments from disassembly output.\n"
"\n"
".BR --no-comments\n"
"same as -nc\n"
"\n"
".BR -m\n"
"print this manual, in case some jerk forgets to give it to you, so you can echo it out to a file.\n"
"\n"
".BR -C\n"
"prints the compiletime environment information.\n"
"\n"
".BR -E\n"
"expands all macros and does not write an output file.\n"
"\n"
".BR -pl\n"
"prints all lines to base assembler file-building instructions (bytes)\n"
"\n"
".SH LANGUAGE\n"
".TP\n"
"Terminology:\n"
".B Address: \n"
"Location where data is stored in main memory\n"
"\n"
".B Register: \n"
"a very fast form of memory which is not part of main memory, like a kind of variable.\n"
"\n"
".B Page: \n"
"256 bytes starting at an address whose low byte is zero.\n"
"\n"
".B Region: \n"
"64 kilobytes starting at an address whose 2 low bytes is zero.\n"
"\n"
".B Zero 'Home' or 'Stack' Region: \n"
"the topmost region, where the stack pointer is stuck and where normal non-far loads and stores happen.\n"
"\n"
".B Device: \n"
"the implementation of gch(), pch(), di(), dcl(), and interrupt from d.h which is used for I/O,\n"
"accessible with getchar, putchar, and interrupt\n"
"in the assembly language.\n"
"\n"
".B Segment:\n"
"The additional region of memory outside the normal SISA16 address space, which is \n"
"allocated at runtime, used for mass storage (the heap). Typically for loading files or extremely large structures,\n"
"but can also be used to hold code.\n"
"\n"
".SH INSTRUCTIONS\n"
"\n"
".TP\n"
"Supported instructions:\n"
"\n"
"halt- end execution (1 byte) (0)\n"
"\n"
"lda- load byte into register a,zero extend (3 bytes)(1)\n"
"\n"
"la - set register a to value (2 bytes) (2)\n"
"\n"
"ldb - load byte into register b, zero extend (3 bytes)(3)\n"
"\n"
"lb - set register b to value (2 bytes) (4)\n"
"\n"
"sc- load 2 constant bytes into c (3 bytes) (5)\n"
"\n"
"sta- store a to location (3 bytes) (6)\n"
"\n"
"stb- store b to location (3 bytes) (7)\n"
"\n"
"add- a = a + b (1 byte) (8)\n"
"\n"
"sub- a = a - b (1 byte) (9)\n"
"\n"
"mul- a = a * b (1 byte) (A)\n"
"\n"
"div- a = a / b (1 byte) (B)\n"
"\n"
"mod- a = a % b (1 byte) (C)\n"
"\n"
"cmp- if(a<b) a = 0; else if(a>b)a=2; else a=1; (1 byte) (D)\n"
"\n"
"jmpifeq- set program counter to c if a == 1 (1 byte) (E)\n"
"\n"
"jmpifneq- set program counter to c if a is not 1 (1  byte) (F)\n"
"\n"
"getchar- read short from device. (Usually standard out) (1 byte) (10)\n"
"\n"
"putchar- write register A as short to device (Usually standard out) (1 byte)(11)\n"
"\n"
"and- a = a & b (1 byte)(12)\n"
"\n"
"or- a = a | b (1 byte)(13)\n"
"\n"
"xor- a = a ^ b (1 byte)(14)\n"
"\n"
"lsh- a <<= b&7 (1 byte)(15)\n"
"\n"
"rsh- a >>= b&7 (1 byte)(16)\n"
"\n"
"ilda- a = read(c), indirectly access memory through register c and load it into a (1 byte)(17)\n"
"\n"
"ildb- b = read(c), indirectly access memory through register c and load it into b (1 byte)(18)\n"
"\n"
"cab- c = a<<8 + b, make c the combination of a and b. (1 byte)(19)\n"
"\n"
"ab- a = b (1 byte)(1A)\n"
"\n"
"ba- b = a (1 byte)(1B)\n"
"\n"
"alc- a = low half of c (1 byte)(1C)\n"
"\n"
"ahc- a = the high half of c (1 byte)(1D)\n"
"\n"
"nop- (1byte) (1E)\n"
"\n"
"cba c = b<<8 + a, make c the other combination of a and b. (1 byte) (1F)\n"
"\n"
"lla, Large Load 2 constant bytes into A (3 bytes)(20)\n"
"\n"
"illda, a = [c], indirectly load 2 bytes into A through C (1 byte)(21)\n"
"\n"
"llb, Large Load 2 constant bytes into B (3 bytes)(22)\n"
"\n"
"illdb b = [c], indirectly load 2 bytes int B through C (1 byte)(23)\n"
"\n"
"illdaa, a = [a] indirectly load 2 bytes into A through A (1 byte)(24)\n"
"\n"
"illdbb, b = [b] indirectly load 2 bytes into B through B (1 byte)(25)\n"
"\n"
"illdab, a = [b] indirectly load 2 bytes into A through B (1 byte)(26)\n"
"\n"
"illdba, b = [a] indirectly load 2 bytes into B through A (1 byte)(27)\n"
"\n"
"ca c=a (1 byte)(28)\n"
"\n"
"cb c=b (1 byte)(29)\n"
"\n"
"ac a=c (1 byte)(2A)\n"
"\n"
"bc b=c (1 byte)(2B)\n"
"\n"
"ista, [c] = a, (as byte) store a at the location pointed to by C (1 byte)(2C)\n"
"\n"
"istb, [c] = b, (as byte) store b at the location pointed to by C (1 byte)(2D)\n"
"\n"
"istla, [c] = a, (as short) indirectly store large a at the location pointed to by C(1 byte)(2E)\n"
"\n"
"istlb, [c] = b, (as short) indirectly store large b at the location pointed to by C(1 byte)(2F)\n"
"\n"
"jmp, unconditionally jump to the location pointed to by c. (1 byte) (30)\n"
"\n"
"stla, store large A at constant address (3 bytes) (31)\n"
"\n"
"stlb, store large B at constant address (3 bytes) (32)\n"
"\n"
"stc, store C at constant address (3 bytes) (33)\n"
"\n"
"push, stp+=val, add to the stack pointer by a number of bytes (3 bytes) (34)\n"
"\n"
"pop, stp-=val, subtract from the stack pointer by a number of bytes (3 bytes) (35)\n"
"\n"
"pusha, stp+=a, add a to the stack pointer (1 byte) (36)\n"
"\n"
"popa, stp-=a, sub a from the stack pointer (1 byte) (37)\n"
"\n"
"astp, a = stp (1 byte) (38)\n"
"\n"
"bstp, b = stp (1 byte) (39)\n"
"\n"
"compl, a = ~a (1 byte) (3A)\n"
"\n"
"cpc, c = the program counter. (1 byte) (3B)\n"
"\n"
"call: (1 bytes)(3C)\n"
"write the program counter to the stack pointer. Push the stack pointer by 2. Jump to c.\n"
"\n"
"ret: (1 byte)(3D)\n"
"subtract 2 from the stack pointer. load the program counter from the stack pointer.\n"
"\n"
"farillda: load short using far memory indexing at [(u8)c<<16 + (u16)b] (1 byte) (3E)\n"
"\n"
"faristla: store short into far memory indexing at [(u8)c<<16 + (u16)b] (1 byte) (3F)\n"
"\n"
"farilldb: load short using far memory indexing at [(u8)c<<16 + (u16)a] (1 byte) (40)\n"
"\n"
"faristlb: store short into far memory indexing at [(u8)c<<16 + (u16)a] (1 byte) (41)\n"
"\n"
"NOTE: Page size is 256 bytes.\n"
"\n"
"farpagel: copy 256 bytes from any page indexed by c to page indexed by a (1 byte) (42)\n"
"\n"
"farpagest: copy 256 bytes to any page indexed by c from page indexed by a (1 byte) (43)\n"
"\n"
"\n"
"lfarpc: pp = a; pc=0; move the program counter offset to a different 64k region of memory. Set PC to 0. (1 byte) (44)\n"
"\n"
"farcall: write the program counter to the stack pointer. \n"
"Push the stack pointer by 2.\n"
"Write the program counter offset to the stack pointer. Set the program counter offset to a. Jump to c. (1 byte) (45)\n"
"\n"
"farret: Subtract 1 from the stack pointer, assign the program counter offset from the stack pointer.\n"
"subtract 2 from the stack pointer. load the program counter from the stack pointer. (jump)\n"
"(1 byte) (46)\n"
"\n"
"farilda: load byte using far memory indexing at [(u8)c<<16 + (u16)b] (1 byte) (47)\n"
"\n"
"farista: store byte into far memory indexing at [(u8)c<<16 + (u16)b] (1 byte) (48)\n"
"\n"
"farildb: load byte using far memory indexing at [(u8)c<<16 + (u16)a] (1 byte) (49)\n"
"\n"
"faristb: store byte into far memory indexing at [(u8)c<<16 + (u16)a] (1 byte) (4A)\n"
"\n"
".B FIXED POINT OPERATIONS: \n"
"16 multiply instructions. add and subtract carry over.\n"
"ranging from 4B to 5A. All 1 byte.\n"
"\n"
"imul15.1: fixed-point multiply of a and b, 15.1\n"
"\n"
"imul14.2: fixed-point multiply of a and b\n"
"\n"
"imul13.3: fixed-point multiply of a and b\n"
"\n"
"imul12.4: fixed-point multiply of a and b\n"
"\n"
"imul11.5: fixed-point multiply of a and b\n"
"\n"
"imul10.6: fixed-point multiply of a and b\n"
"\n"
"imul9.7: fixed-point multiply of a and b\n"
"\n"
"imul8.8: fixed-point multiply of a and b\n"
"\n"
"imul7.9: fixed-point multiply of a and b\n"
"\n"
"imul6.10: fixed-point multiply of a and b\n"
"\n"
"imul5.11: fixed-point multiply of a and b\n"
"\n"
"imul4.12: fixed-point multiply of a and b\n"
"\n"
"imul3.13: fixed-point multiply of a and b\n"
"\n"
"imul2.14: fixed-point multiply of a and b\n"
"\n"
"imul1.15: fixed-point multiply of a and b\n"
"\n"
"imul.16: fixed-point multiply of a and b\n"
"\n"
"alpush: push short register a onto the stack. (1 byte) (5B)\n"
"\n"
"blpush: push short register b onto the stack. (1 byte) (5C)\n"
"\n"
"cpush: push short register c onto the stack. (1 byte) (5D)\n"
"\n"
"apush: push byte register a onto the stack. (1 byte) (5E)\n"
"\n"
"bpush: push byte register b onto the stack. (1 byte) (5F)\n"
"\n"
"alpop: pop short register a from the stack. (1 byte) (60)\n"
"\n"
"blpop: pop short register b from the stack. (1 byte) (61)\n"
"\n"
"cpop: pop short register c from the stack. (1 byte) (62)\n"
"\n"
"apop: pop byte register a from the stack. (1 byte) (63)\n"
"\n"
"bpop: pop byte register b from the stack. (1 byte) (64)\n"
"\n"
"interrupt: pass the registers to the user defined \"interrupt\" function (1 byte) (65)\n"
"\n"
"clock: set register a to the execution time in thousandths of a second. (1 byte) (66)\n"
"Register B will be the time in seconds. \n"
"C will be the raw number of clock cycles.\n"
"\n"
".B SISA16 32 BIT EXTENSION\n"
"\n"
"arx0: load RX0 into A. (1 byte) (67)\n"
"\n"
"brx0: load RX0 into B. (1 byte) (68)\n"
"\n"
"crx0: load RX0 into C. (1 byte) (69)\n"
"\n"
"rx0a: load A into RX0. (1 byte) (6A)\n"
"\n"
"rx0b: load B into RX0. (1 byte) (6B)\n"
"\n"
"rx0c: load C into RX0. (1 byte) (6C)\n"
"\n"
"arx1: load RX1 into A. (1 byte) (6D)\n"
"\n"
"brx1: load RX1 into B. (1 byte) (6E)\n"
"\n"
"crx1: load RX1 into C. (1 byte) (6F)\n"
"\n"
"rx1a: load A into RX1. (1 byte) (70)\n"
"\n"
"rx1b: load B into RX1. (1 byte) (71)\n"
"\n"
"rx1c: load C into RX1. (1 byte) (72)\n"
"\n"
"arx2: load RX2 into A. (1 byte) (73)\n"
"\n"
"brx2: load RX2 into B. (1 byte) (74)\n"
"\n"
"crx2: load RX2 into C. (1 byte) (75)\n"
"\n"
"rx2a: load A into RX2. (1 byte) (76)\n"
"\n"
"rx2b: load B into RX2. (1 byte) (77)\n"
"\n"
"rx2c: load C into RX2. (1 byte) (78)\n"
"\n"
"arx3: load RX3 into A. (1 byte) (79)\n"
"\n"
"brx3: load RX3 into B. (1 byte) (7A)\n"
"\n"
"crx3: load RX3 into C. (1 byte) (7B)\n"
"\n"
"rx3a: load A into RX3. (1 byte) (7C)\n"
"\n"
"rx3b: load B into RX3. (1 byte) (7D)\n"
"\n"
"rx3c: load C into RX3. (1 byte) (7E)\n"
"\n"
"rx0_1: RX0 = RX1; (1 byte) (7F)\n"
"\n"
"rx0_2: RX0 = RX2; (1 byte) (80)\n"
"\n"
"rx0_3: RX0 = RX3; (1 byte) (81)\n"
"\n"
"rx1_0: RX1 = RX0; (1 byte) (82)\n"
"\n"
"rx1_2: RX1 = RX2; (1 byte) (83)\n"
"\n"
"rx1_3: RX1 = RX3; (1 byte) (84)\n"
"\n"
"rx2_0: RX2 = RX0; (1 byte) (85)\n"
"\n"
"rx2_1: RX2 = RX1; (1 byte) (86)\n"
"\n"
"rx2_3: RX2 = RX3; (1 byte) (87)\n"
"\n"
"rx3_0: RX3 = RX0; (1 byte) (88)\n"
"\n"
"rx3_1: RX3 = RX1; (1 byte) (89)\n"
"\n"
"rx3_2: RX3 = RX2; (1 byte) (8A)\n"
"\n"
"lrx0: load 4 constant bytes (highest, high, low, lowest) into RX0. (5 bytes) (8B)\n"
"\n"
"lrx1: load 4 constant bytes (highest, high, low, lowest) into RX1. (5 bytes) (8C)\n"
"\n"
"lrx2: load 4 constant bytes (highest, high, low, lowest) into RX2. (5 bytes) (8D)\n"
"\n"
"lrx3: load 4 constant bytes (highest, high, low, lowest) into RX3. (5 bytes) (8E)\n"
"\n"
"farildrx0: load RX0 from memory location M[(c&255)<<16 + a] (1 byte) (8F)\n"
"\n"
"farildrx1: load RX1 from memory location M[(c&255)<<16 + a] (1 byte) (90)\n"
"\n"
"farildrx2: load RX2 from memory location M[(c&255)<<16 + a] (1 byte) (91)\n"
"\n"
"farildrx3: load RX3 from memory location M[(c&255)<<16 + a] (1 byte) (92)\n"
"\n"
"faristrx0: store RX0 at memory location M[(c&255)<<16 + a] (1 byte) (93)\n"
"\n"
"faristrx1: store RX1 at memory location M[(c&255)<<16 + a] (1 byte) (94)\n"
"\n"
"faristrx2: store RX2 at memory location M[(c&255)<<16 + a] (1 byte) (95)\n"
"\n"
"faristrx3: store RX3 at memory location M[(c&255)<<16 + a] (1 byte) (96)\n"
"\n"
"rxadd: RX0 += RX1;(1 byte) (97)\n"
"\n"
"rxsub: RX0 -= RX1;(1 byte) (98)\n"
"\n"
"rxmul: RX0 *= RX1;(1 byte) (99)\n"
"\n"
"rxdiv: RX0 /= RX1;(1 byte) (9A)\n"
"\n"
"rxmod: RX0 %= RX1;(1 byte) (9B)\n"
"\n"
"rxrsh: RX0 >>= RX1;(1 byte) (9C)\n"
"\n"
"rxlsh: RX0 <<= RX1;(1 byte) (9D)\n"
"\n"
"rx0push: push 32 bit RX0 register onto the stack. (1 byte) (9E)\n"
"\n"
"rx1push: push 32 bit RX1 register onto the stack. (1 byte) (9F)\n"
"\n"
"rx2push: push 32 bit RX2 register onto the stack. (1 byte) (A0)\n"
"\n"
"rx3push: push 32 bit RX3 register onto the stack. (1 byte) (A1)\n"
"\n"
"rx0pop: pop 32 bit RX0 register from the stack. (1 byte) (A2)\n"
"\n"
"rx1pop: pop 32 bit RX1 register from the stack. (1 byte) (A3)\n"
"\n"
"rx2pop: pop 32 bit RX2 register from the stack. (1 byte) (A4)\n"
"\n"
"rx3pop: pop 32 bit RX3 register from the stack. (1 byte) (A5)\n"
"\n"
"rxand: RX0 &= RX1(1 byte) (A6)\n"
"\n"
"rxor: RX0 |= RX1(1 byte) (A7)\n"
"\n"
"rxxor: RX0 ^= RX1(1 byte) (bitwise XOR) (A8)\n"
"\n"
"rxcompl: RX0 = ~RX0; bitwise inversion, 1's complement.(1 byte) (A9)\n"
"\n"
"rxcmp:\tif(RX0<RX1)a=0;else if(RX0>RX1)a=2;else a=1;  (1 byte) (AA)\n"
"\n"
"seg_ld: load segment RX1 into page RX0 of Main Memory. (1 byte) (AB)\n"
"\n"
"seg_st: store segment RX0 from main memory into page RX1 in the segment. (1 byte) (AC)\n"
"\n"
"seg_realloc: resize the segment to size specified by RX0. if RX0 is 0, then an error flag is returned. (1 byte) (AD)\n"
"\n"
"fltadd: floating point addition, RX0 += RX1, disabled with -DNO_FP (1 byte) (AE)\n"
"\n"
"fltsub: (1 byte) (AF)\n"
"\n"
"fltmul: (1 byte) (B0)\n"
"\n"
"fltdiv: divide by zero is erroneous. (1 byte) (B1)\n"
"\n"
"fltcmp: if(RX0<RX1)a=0;else if(RX0>RX1)a=2;else a=1;, but RX0 and RX1 are treated as floating point (1 byte) (B2)\n"
"\n"
"seg_pages: get the number of pages in the segment in RX0. (1 byte) (B3)\n"
"\n"
"ildrx0_1: indirectly load rx0 by using rx1. (1 byte) (B4)\n"
"\n"
"ildrx0_0: indirectly load rx0 by using rx0. (1 byte) (B5)\n"
"\n"
"farjmprx0: jump to location pointed to by rx0. (1 byte) (B6)\n"
"\n"
"istrx0_1: store rx0 at the location pointed to by rx1. (1 byte) (B7)\n"
"\n"
"istrx1_0: store rx1 at the location pointed to by rx0. (1 byte) (B8)\n"
"\n"
"cbrx0: c = RX0>>16; b = RX0 & 0xffFF; (1 byte) (B9)\n"
"\n"
"carx0: c = RX0>>16; a = RX0 & 0xffFF; (1 byte) (BA)\n"
"\n"
"rxidiv: RX0 = (signed)RX0 / (signed)RX1 (1 byte) (BB)\n"
"\n"
"rximod: RX0 = (signed)RX0 % (signed)RX1 (1 byte) (BC)\n"
"\n"
"farldrx0: load RX0 from constant memory location (4 bytes) (BD)\n"
"\n"
"farldrx1: (4 bytes) (BE)\n"
"\n"
"farldrx2: (4 bytes) (BF)\n"
"\n"
"farldrx3: (4 bytes) (C0)\n"
"\n"
"farllda: (4 bytes) (C1)\n"
"\n"
"farlldb: (4 bytes) (C2)\n"
"\n"
"farldc: (4 bytes) (C3)\n"
"\n"
"farstrx0: store rx0 to constant memory location (4 bytes) (C4)\n"
"\n"
"farstrx1: (4 bytes) (C5)\n"
"\n"
"farstrx2: (4 bytes) (C6)\n"
"\n"
"farstrx3: (4 bytes) (C7)\n"
"\n"
"farstla: (4 bytes) (C8)\n"
"\n"
"farstlb: (4 bytes) (C9)\n"
"\n"
"farstc: (4 bytes) (CA)\n"
"\n"
"aincr: (1 byte) (CB)\n"
"\n"
"adecr: (1 byte) (CC)\n"
"\n"
"rxincr: (1 byte) (CD)\n"
"\n"
"rxdecr: (1 byte) (CE)\n"
"\n"
"emulate: Run a SISA16 sandboxed machine sharing the segment and a single page of choice according to register A (1 byte) (CF)\n"
"\tErrors in the sandboxed machine are trapped and returned to register A.\n"
"\n"
"\tThe segment is also sandboxed and a new 256 byte segment is allocated for the child program.\n"
"\t\n"
"\tthe maximum recursion allowed by the implementation is defined by SISA16_MAX_RECURSION_DEPTH in isa_pre.h\n"
"\n"
"rxitof: convert RX0 from signed int to float. (1 byte) (D0)\n"
"\n"
"rxftoi: convert RX0 from float to signed int. (1 byte) (D1)\n"
"\n"
"emulate_seg: Same as Emulate, but the segment is passed down to the child. (1 byte) (D2)\n"
"\n"
"rxicmp: comparison like rxcmp, but for signed 32 bit integers. (1 byte) (D3)\n"
"\n"
"The rest: nop duplicates, free for expansion (1 byte)\n"
"\n"
".TP\n"
".B Comments\n"
"comment lines are lines that begin with // or #.\n"
"\n"
".TP\n"
".B Labels\n"
"\n"
"Labels must always be on their own lines. Labels are just macros that contain only a number indicating\n"
"a location in the code.\n"
"\n"
"VAR#myLabel#@\n"
"\n"
"is one way of doing a label.\n"
"\n"
":myLabel:\n"
"\n"
"is the syntactic sugar for the same.\n"
"\n"
".TP\n"
".B Macros\n"
"\n"
"Macros are defined with VAR# lines.\n"
"\n"
"VAR#myMacro#myMacroExpansion\n"
"\n"
"everything after the second # is part of the macro.\n"
"\n"
"Several built-in macros are evaluated inside of macro definitions, such as @ and $.\n"
"\n"
".TP\n"
".B Syntactic Sugar\n"
"\n"
"There are various extremely common operations in sisa16 that have syntactic sugars available\n"
"\n"
"These Syntactic sugar lines must have nothing else on them, not even comments.\n"
"They may have preceding whitespace only! nothing else.\n"
"\n"
"\".myMacro:definition\"\n"
"\n"
"is syntactic sugar for\n"
"\n"
"VAR#myMacro#definition\n"
"\n"
"\":myLabel:\"\n"
"\n"
"is syntactic sugar for\n"
"\n"
"VAR#myLabel#@\n"
"\n"
"\"..decl_farproc:myProcedure\"\n"
"\n"
"is syntactic sugar for\n"
"\n"
"VAR#myProcedure#sc %@%;la region;farcall;\n"
"\n"
"\"..decl_lproc:myProcedure\"\n"
"\n"
"is syntactic sugar for\n"
"\n"
"VAR#myProcedure#sc%@%;call;\n"
"\n"
"\"..include\"file.h\"\" is syntactic sugar for \"ASM_header file.h\"\n"
"\n"
"\"..include \"file.h\"\" is syntactic sugar for \"ASM_header file.h\", it must have exactly one space.\n"
"\n"
"The following syntactic sugars are allowed to prefix something,\n"
"they must be at the beginning of a line, after preceding whitespace:\n"
"\n"
"\"..zero:\" is syntactic sugar for \"section0;\"\n"
"\n"
"\"..(37):\" is syntactic sugar for \"section2424832;\". It selects a region. \n"
"\n"
"\"..ascii:Hello World!\" is syntactic sugar for \"!Hello World!\"\n"
"\n"
"\"..asciz:Hello World!\" is syntactic sugar for \"!Hello World!\" followed by a line which says \"bytes0\"\n"
"\n"
"(Note that you shouldn't enter quotes for any of these)\n"
"\n"
".TP\n"
".B Evaluation Sequence Points (|)\n"
"\n"
"you can use the unix pipe character | to stop the evaluation of macros to a certain point. \n"
"Not only this, but full file writing is done as well, meaning that evaluations of @ between sequence points\n"
"results in different values.\n"
"\n"
".TP\n"
".B Headers\n"
"\n"
"ASM_header can be used to include asm files into a program, from the current working directory or SISA16BIN or\n"
"your home folder /sisa16/, or /usr/include/sisa16/\n"
"\n"
".TP\n"
".B Data\n"
"\n"
"ASM_data_include can be used to include raw binary data into the output.\n"
"\n"
"\n"
".TP\n"
".B String Literal Lines\n"
"\n"
"string literal lines start with an exclamation mark. Every character after the exclamation mark is part of the string.\n"
"the raw characters are written to the output file (ASCII)\n"
"\n"
".TP\n"
".B Newline Escapes\n"
"\n"
"Most lines can be escaped such that two lines are merged by using \\ before the new line.\n"
"\n"
".TP\n"
".B section\n"
"\n"
"you can move the output counter anywhere in the file using section\n"
"\n"
"//move to to the first non-home region\n"
"\n"
"section 0x10000\n"
"\n"
".TP\n"
".B fill\n"
"\n"
"fill a region with a constant byte value\n"
"\n"
"fill size,val\n"
"\n"
".TP\n"
".B bytes\n"
"\n"
"write bytes to the output file.\n"
"\n"
"bytes 1,2,3,0xE7,0xA1;\n"
"\n"
".TP\n"
".B shorts\n"
"\n"
"write shorts to the output file, with high byte first.\n"
"\n"
"shorts 0xFFEE, 0x0011;\n"
"\n"
"is semantically equivalent to...\n"
"\n"
"bytes 0xFF, 0xEE, 0x00, 0x11;\n"
"\n"
".TP\n"
".B asm_vars\n"
"\n"
"write out all variables (not done with -run) to standard out during assembly\n"
"\n"
".TP\n"
".B asm_print\n"
"\n"
"print the status of the assembler at the line.\n"
"\n"
".TP\n"
".B asm_fix_outputcounter\n"
"\n"
"make a correction to the output counter on the second pass.\n"
"\n"
"asm_fix_outputcounter +50\n"
"\n"
"\n"
".TP\n"
".B asm_begin_region_restriction\n"
"\n"
"restrict the output counter to the current region and emit an assemblytime error if the output\n"
"counter leaves the current region (64k)\n"
"\n"
".TP\n"
".B asm_begin_block_restriction\n"
"\n"
"the same, but for pages (256 bytes)\n"
"\n"
".TP\n"
".B asm_end_restriction\n"
"\n"
"End the active restriction.\n"
"\n"
".TP\n"
".B asm_quit\n"
"\n"
"halt assembly\n"
"\n"
".TP\n"
".B the dollar sign ($)\n"
"\n"
"builtin macro that expands to the current output counter as a high-low byte pair. Is expanded inside of\n"
"macro definitions to allow for labels to be constructed.\n"
"\n"
".TP\n"
".B the at sign (@)\n"
"\n"
"builtin macro that expands to the current output counter. Is expanded inside of macro\n"
"definitions for labels.\n"
"\n"
".TP\n"
".B SPLIT (%%)\n"
"\n"
"builtin macro expand a number into a high-low byte pair.\n"
"\n"
"sc %32%;\n"
"\n"
"expands to\n"
"\n"
"sc 0,32;\n"
"\n"
"it is NOT evaluated at macro definition time.\n"
"\n"
".TP\n"
".B SPLIT8 (%~%)\n"
"\n"
"builtin macro to evaluate the contained text as an 8 bit number.\n"
"\n"
"This allows forward declaration of an 8 bit constant to be utilized, the same way\n"
"you can forward declare a 16/24/32 bit constant and use it with other splits.\n"
"\n"
"la %~5%;\n"
"\n"
"is equvalent to\n"
"\n"
"la 5;\n"
"\n"
".TP\n"
".B SPLIT32 (%/%)\n"
"\n"
"builtin macro to expand numbers into 4 bytes (highest, high, low, lowest)\n"
"\n"
"lrx0 %/50%;\n"
"\n"
"expands to\n"
"\n"
"lrx0 0,0,0,50;\n"
"\n"
".TP\n"
".B SPLIT32NEG (%-%)\n"
"\n"
"builtin macro to expand numbers into 4 bytes (highest, high, low, lowest) two's complement.\n"
"\n"
"lrx0 %-1%;\n"
"\n"
"expands to\n"
"\n"
"lrx0 255,255,255,255;\n"
"\n"
".TP\n"
".B SPLITFLOAT (%?%)\n"
"\n"
"builtin macro to convert floating point numbers into their 32 bit unsigned integer representations.\n"
"\n"
"This is platform-dependent.\n"
"\n"
"lrx0 %?3.0%;\n"
"\n"
"expands to a platform-specific floating-point conversion of 3.0 to an unsigned integer, as individual bytes.\n"
"\n"
".TP\n"
".B SPLIT24 (%&%)\n"
"\n"
"builtin macro to convert 32 bit unsigned integers into 24 bit counterparts.\n"
"\n"
"farstrx0 %&0xAE0000%;\n"
"\n"
"is semantically equivalent to:\n"
"\n"
"farstrx0 0xAE, 0x00, 0x00;\n"
"\n"
".TP\n"
".B Macro definition semantics\n"
"\n"
".TP\n"
"Macros may only be defined by the following:\n"
"\n"
"1) VAR# lines define a macro to be all of the text after the second pound symbol.\n"
"\n"
".TP\n"
"This is what happens when you define a macro:\n"
"\n"
"1) a VAR# line is recognized.\n"
"\n"
"2) Builtin macros @ and $ are parsed inside of the line, but no others (including whitespace reduction)\n"
"\n"
"3) Assembler Pass Semantics:\n"
"\n"
"If on the first pass of the assembler, the macro is checked to see if it already exists.\n"
"\n"
"if it does, a warning may be emitted about a redefinining macro.\n"
"\n"
"If on the second passs of the assembler and the macro was not redefining on the first pass,\n"
"\n"
"checks to ensure that the macro evaluates to the same value are done. if the macro does not evaluate the same,\n"
"\n"
"a warning is emitted, even if using -run.\n"
"\n"
"4) Line processing does not proceed to instruction translation or file writing.\n"
"\n"
".TP\n"
".B Macro Evaluation semantics\n"
"\n"
"The assembler follows this order of execution, for every line, roughly:\n"
"\n"
"1) Backslash newline escapes (for non-special line types) are handled, and preceding whitespace is removed.\n"
"\n"
"2) Special line types are recognized (String literal, ASM_header, ASM_data_include, syntactic sugars, and ASM_compile)\n"
"which do not involve any macro definition. \n"
"\n"
"3) The line is checked to see if it is a macro line (VAR#)\n"
"\n"
"5) Macros are expanded on the current line, until the first vertical bar. If at any point one of the\n"
"pre-processing macros is discovered before the first vertical bar, jump back to 3. VAR# lines only have the $ and @ symbols parsed...\n"
"until the first vertical bar. Past the first vertical bar inside the macro definition, no macro\n"
"expansion is done whatsoever.\n"
"\n"
"6) Once all macros are expanded on the line until the first vertical bar (|, the unix pipe character)...\n"
"\n"
"7) Macro definition is handled.\n"
"\n"
"8) Instruction expansion (into bytes) is done.\n"
"\n"
"9) File writing and assembler instruction is done, up to the first vertical bar. File writing is only done\n"
"on the second pass, but on the first pass, the output counter is still moved.\n"
"\n"
"10) if the line contains vertical bars, the line up to the first vertical bar is removed and the line is re-evaluated,\n"
"from 3 onward. Note that you should NOT put VAR# definitions ANYWHERE except on their own line, it is undefined behavior.\n"
"\n"
".TP\n"
".B Error handling semantics\n"
"\n"
"if at any point a critical error occurs and the assembler detects it, assembly is aborted.\n"
"\n"
"Unusual or noteworthy phenomenon will be made into warnings, unless on -run\n"
"\n"
"Macro desynchronization between passes (Helpful for recognizing bad labels!) will cause a warning even if\n"
"the assembler is invoked with -run.\n"
"\n"
".TP\n"
".B Undefined and Prohibited behavior\n"
"\n"
"1) You may not put a VAR# definition anywhere other than the beginning of a line.\n"
"\n"
"2) You may not evaluate the at sign or dollar sign inside of a macro if it is beyond a vertical bar.\n"
"\n"
"3) You may not define a macro whose name contains reserved symbols such as $, @, %, |, etc.\n"
"\n"
"4) You may not define a macro which would prevent the use of an instruction.\n"
"\n"
"5) You may not construct a macro whose name starts with the name of an instruction. \"lbl_mylabel\" is prohibited,\n"
"for instance, because it starts with \"lb\". This prevents you from defining \"lb0\" which would prevent you from loading\n"
"zero into register B.\n"
"\n"
"6) You may not include a file larger than SISA16's address space (16MB)\n"
"\n"
"7) You may not violate an active block (page) or region restriction unless it is disabled or changed.\n"
"\n"
"8) You may not enter a sequence of characters which does not finally resolve into valid commands for the assembler.\n"
"\n"
"9) You may not use an incorrect number of arguments for an instruction.\n"
"\n"
"10) You may not put a comma immediately after an instruction's name.\n"
"\n"
"11) You may not exceed the macro recursion limit (You will break it if you try) of 65535 expansions.\n"
"\n"
"12) You may not have more than 20 levels of header includes (This is configurable.)\n"
"\n"
".TP\n"
".B Command and argument Separation\n"
"Individual commands are separated with semicolons, and sequence points on the same line are defined with vertical bars.\n"
"\n"
"Arguments to commands are separated with commas, but the first never needs a comma.\n"
"\n"
"la13;lb1;add;apush;\n"
"\n"
"is semantically equivalent to\n"
"\n"
"la 13;\n"
"\n"
"lb 1;\n"
"\n"
"add;\n"
"\n"
"apush;\n"
"\n"
"but the latter is four separate lines and may assemble slightly slower.\n"
"\n"
".TP\n"
".B Debugging Assembly\n"
"\n"
"you can pass -DBG to the assembler to get extended debug output.\n"
"\n"
"you can pass -E to the assembler to expand all macros.\n"
"\n"
"you can pass -pl to the assembler to print the lines as they're parsed (Sequence points break this somewhat)\n"
"\n"
"if you want more concise debugging, you can use asm_print or asm_vars.\n"
"\n"
"Both asm_print and asm_vars do no checking of their arguments but normal evaluation is done, \n"
"so if you want to have debug values display, it is optimal to make a line:\n"
"\n"
"//a line.\n"
"\n"
"\tasm_print myMacro;\n"
"\n"
"the line will be printed asn you will see this:\n"
"\n"
"asm_printmyMacroExpansionNoticeNoWhitespaces;\n"
"\n"
"alongside the original line in the printout.\n"
"\n"
".TP\n"
".B Debugging programs\n"
"\n"
"No debugger exists for SISA16 as of writing this. However, you can implement interrupts to perform\n"
"\n"
"memory dumps, display registers, etcetera.\n"
"\n"
"you can also print to the terminal with getchar and putchar (with the default d.h terminal driver...)\n"
"\n"
"Inside of clock.asm, string printing and byte printing in hex is implemented. You can use this in place\n"
"of printf if you were doing C code.\n"
"\n"
".TP\n"
".B Platform Semantics\n"
"\n"
"1) SISA16 is big endian. the highest bytes are stored first.\n"
"\n"
"2) the stack pointer grows up.\n"
"\n"
"3) the stack pointer points to the first free byte.\n"
"\n"
"4) The stack pointer is sixteen bit and trapped in the home region, 0x0000 to 0xFFFF.\n"
"\n"
"5) all memory reads and writes wrap around inside of regions. if you try to far indirect load on a\n"
"\n"
"region boundary, it will wrap around inside that region.\n"
"\n"
"6) Program execution begins at 0. It is best practice to immediately set the A register to some region number\n"
"and lfarpc into a main routine as a bootloader.\n"
"\n"
"7) All integers are unsigned, but twos complement can be simulated. add subtract multiply all work\n"
"with twos complement numbers. To make a number negative, simply take the complement (compl or rxcompl) and add one.\n"
"\n"
"8) when a command refers to the A or B registers, an extra \"l\" will be included to indicate 16 bit instructions,\n"
"otherwise, it is 8 bit. The C register is always 16 bit and no such distinction is made for it.\n"
"\n"
"alpop vs apop, apop works with a single byte on the stack, but alpop loads 2 bytes (big endian).\n"
"but there is no clpop, only cpop, which is 16 bit.\n"
"\n"
"9) call and ret work within the same region, if you want to write subroutines across regions, use farcall and farret.\n"
"\n"
"call and ret are more efficient than farcall and farret, though. If you know you're only going to use a function\n"
"within a single region, then call is safe.\n"
"\n"
"10) there are no jmpiflt or jmpifgt instructions. use cmp.\n"
"\n"
"//macro to load your value into register A.\n"
"\n"
"ld_value1;\n"
"\n"
"//this will jump to myLabel if value1 is less than 3. cmp returns 0 if a is less than b, 1 if equal, or 2 if greater than.\n"
"\n"
"lb 3;cmp;lb0;cmp;sc%myLabel%;jmpifeq;\n"
"\n"
"11) Generally, as a convention, the 16 bit registers ABC are used for control flow and low level math, but\n"
"RX0-3 are used for 32 bit mathematics.\n"
"\n"
".TP\n"
".B Potentially confusing behavior in the assembler\n"
"\n"
".TP\n"
"Macro Expansion\n"
"\n"
"if you have one macro,\n"
"\n"
"myMacro\n"
"\n"
"and another macro,\n"
"\n"
"myMacro1\n"
"\n"
"and myMacro1 is defined after myMacro, then all references to myMacro1\n"
"before its definition will be expanded as if it was myMacro followed\n"
"by the \"1\" character. (on pass 1!)\n"
"\n"
"This can be particularly confusing for goto labels, since goto labels\n"
"are often defined after where they are used (So that they will expand\n"
"correctly on the second pass.)\n"
"\n"
"Note that the order is important here. if you define myMacro1 before myMacro,\n"
"then the assembler will detect there is a longer macro to expand which intersects the location,\n"
"and will instead use that.\n"
"\n"
".TP\n"
"Interesting little language, don't you think?\n"
"\n"
".SH AUTHOR\n"
"David MHS Webster, 2021\n"
"\n"
"Email me: davidmhswebster@gmail.com\n"
"\n"
"\"Let all that you do be done with love\"\n"
"\n"
".SH LICENSE\n"
"For the Public Domain. See CC0 License.\n"
""
