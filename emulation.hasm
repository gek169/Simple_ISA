

//~~~~~~~~~~~~~~~~~~
//~~emulate_single~~
//~~~~~~~~~~~~~~~~~~
//Do you want to run user code in a single process with zero overhead?
//This must be placed at a region boundary, so it must be first.
//Both of the following functions take a jump point in RX0.
//They take a page to share with the client in the second parameter, so memory can be shared.
//The return values from the machine are not provided to the caller.
//krenel also uses it.

//These four nops are very important.
nop;nop;nop;nop;
farldrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%; //HUGE NOTE: upon a boot of the libc, this will load zeroes.
farstrx0 %&0%
.libc_krenel_jumploc:@+1+
lrx0 %/libc_booter%;
farjmprx0;
:libc_krenel_stack_data_store:
nop;nop;nop;nop;

//Both of these functions use register B to store the page that 

..decl_farproc(LIBC_REGION):proc_emulate_single
..export"proc_emulate_single"
	//We are passed a place to jump to in RX0.
	farstrx0 %~LIBC_REGION%, %libc_krenel_jumploc%;
	//We must memcpy three bytes, so we memcpy 4.
	farldrx0 %&0%
	farstrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
	sc %0%; la 2; ista; //la
	adecr;ca;			//put 1 into c.
	lla %~LIBC_REGION%, 0x44; istla;
	ab;
	emulate;
	//restore stack integrity.
		farldrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
		farstrx0 %&0%
	//a holds the value. CHECK IT.
	libc_emulate_single_cswitch_looptop:
		alpush;
		lb 19; cmp; blpop; sc %libc_emulate_single_syscall%; jmpifeq;
		ab; alpush;
		lb 18; cmp; blpop; sc %libc_emulate_single_interrupt%; jmpifeq;
		ab; alpush;
		lb 17; cmp; blpop; sc %libc_emulate_single_putchar%; jmpifeq;
		ab; alpush;
		lb 16; cmp; blpop; sc %libc_emulate_single_getchar%; jmpifeq;
		ab; alpush;
		lb 0xff; cmp; blpop; sc %libc_emulate_single_preempt%; jmpifeq;
		sc %libc_emulate_single_cswitch_loopout%; jmp;
	libc_emulate_single_syscall:
		//TODO: provide services.
		sc %libc_emulate_single_preempt%; jmp;
	libc_emulate_single_interrupt:
		user_getb;ba;
		user_getc;ca;
		user_geta;
		user_get1;rx1_0;
		user_get2;rx2_0;
		user_get3;rx3_0;
		user_get0;
		interrupt;
		user_seta;
		sc %libc_emulate_single_preempt%; jmp;
	libc_emulate_single_getchar:
		getchar;
		user_seta;
		sc %libc_emulate_single_preempt%; jmp;
	libc_emulate_single_putchar:
		user_geta;
		putchar;
//		sc %libc_emulate_single_preempt%; jmp;
	libc_emulate_single_preempt:
		task_ric;
		priv_drop;
		sc %libc_emulate_single_cswitch_looptop%; jmp;
	libc_emulate_single_cswitch_loopout:
farret;







..include"printbytehex.hasm"
..include"fdisk.hasm"
..include"puts.hasm"
..include"strlen.hasm"
..include"memcpy.hasm"
..include"gets.hasm"
..include"atoi_dec.hasm"
..include"atof_dec.hasm"
..include"sqrt.hasm"
..include"wait.hasm"
..include"termcontrol.hasm"
..include"alloc.hasm"
..include"strutil.hasm"

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~K R E N E L~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//Give it a location to boot as PID 0, and it will, in RX0.

..decl_lproc:libc_lproc_krenel_print_krenel
	la 'K'; putchar;
	la 'R'; putchar;
	la 'E'; putchar;
	la 'N'; putchar;
	la 'E'; putchar;
	la 'L'; putchar;
	la '\:'; putchar;
	la '\ '; putchar;
	ret



//krenel constants:
//MUST BE A POWER OF TWO, must be identical to the constant in isa_pre.h SISA_MAX_TASKS
.libc_krenel_max_active_tasks:8
//Must be one less than that power of two, for an "and" mask:
.libc_krenel_max_active_tasks_mask:7
//Maximum number of times a syscall or interrupt can be made before a context switch occurs.
.libc_krenel_max_returns:100
//the region where code to execute is stored.
.libc_krenel_exec_region:1

//the region which is used for file descriptors.
.libc_krenel_fd_table_region:0xFEFF

//1 megabyte is needed for the diskmap.
.libc_krenel_diskmap_super_region:0x40

//200 megabytes. Don't spam GH
.libc_krenel_max_disk_usage:0x100000


//Reserved page for disk IO.
.libc_krenel_diskio_page:0xFF00
.libc_krenel_diskio_next_page:0xFF01
//We reserve 2 megabytes for creating a PID0 program.
//we reserve an additional megabyte for the FAT.
//The rest is available and free.
//This is by *page*.
.libc_krenel_disk_reserved:0x3000


//Given a file size in RX0, find a start page. If none can be found, return 0xffFFffFF, which is erroneous.
.decl_lproc:libc_lproc_krenel_find_free:
	//TODO
	lrx0 %/0xffFFffFF%;
	ret;

//Load user page according to register B.
.libc_lproc_krenel_load_user_page:\
	user_getb;ca;\
	lla %libc_krenel_diskio_page%;\
	user_farpagel;

//all tasks start out as 0- inactive.
//these are shorts.
:libc_krenel_task_isactive_array:
bytes 0,0,  0,0;
bytes 0,0,  0,0;
bytes 0,0,  0,0;
bytes 0,0,  0,0;
bytes 0,0,  0,0;
bytes 0,0,  0,0;
bytes 0,0,  0,0;


:libc_krenel_task_nreturns:
bytes 0,0;

:libc_krenel_active_task_index:
bytes 0,0;

..decl_farproc(LIBC_REGION):proc_krenel
..export"proc_krenel"
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~ KRENEL STARTUP ROUTINE ~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//		libc_lproc_krenel_print_krenel;
//		la 'B'; putchar;
//		la 'O'; putchar;
//		la 'O'; putchar;
//		la 'T'; putchar;
//		la '\n'; putchar;
//		la '\r'; putchar;
//		la '\n'; interrupt;
	//We are passed a place to jump to in RX0. Store it away while we set up the krenel.
		rx0push;
	//Set input mode to be non-blocking.
		lla %0xE000%; interrupt;
		
	//Set the active task's info.
		la 0; farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;	
		la 0; farstla %~LIBC_REGION%, %libc_krenel_active_task_index%;

	//Set all tasks to be zero
		lb0;rx0b; 
		lb libc_krenel_max_active_tasks; rx1b;
		libc_krenel_zero_tasks_looptop:
			arx0;task_set; task_kill;
			arx0;
			lb 2;mul;ba;
			sc %LIBC_REGION%;lla %libc_krenel_task_isactive_array%
			add;ba;
			la 0; faristla;
			rxincr;rxcmp;nota; //nota is just "Is a equal to zero?"
			sc %libc_krenel_zero_tasks_looptop%; jmpifeq;
	//PID 0 is the initial program... make it 1.
		sc %LIBC_REGION%;llb %libc_krenel_task_isactive_array%
		la 1;
		farstla %~LIBC_REGION%,  %libc_krenel_task_isactive_array%;
		la 0; task_set;
	//get that important argument back!
		rx0pop;
		farstrx0 %~LIBC_REGION%, %libc_krenel_jumploc%;
	//We must copy three bytes, so we do 4 for speed's sake.
		farldrx0 %&0%
		farstrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
		sc %0%; la 2; ista; //la
		adecr;ca;			//put 1 into c.
		lla %~LIBC_REGION%, 0x44; istla;	//0x44 is the code for lfarpc.
		emulate;
	//restore stack integrity.
		farldrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
		farstrx0 %&0%
	//a holds the return value. CHECK IT.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~ KRENEL SCHEDULER ROUTINE ~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	libc_krenel_cswitch_looptop:
		alpush; 
		lb 0xff; cmp; blpop; sc %libc_krenel_try_select_task%; jmpifeq;
		ab; alpush;
		lb 19; cmp; blpop; sc %libc_krenel_syscall%; jmpifeq;
		ab; alpush;
		lb 18; cmp; blpop; sc %libc_krenel_tried_interrupt%; jmpifeq; //might as well print out an error message.
		ab; alpush;
		lb 17; cmp; blpop; sc %libc_krenel_putchar%; jmpifeq;
		ab; alpush;
		lb 16; cmp; blpop; sc %libc_krenel_getchar%; jmpifeq;
		ab; alpush;
		lb 0; cmp; blpop; sc %libc_krenel_cswitch_killtask%; jmpifeq;
		la '\r'; putchar; la '\n'; putchar;
		libc_lproc_krenel_print_krenel;
		la 'e'; putchar;
		la 'x'; putchar;
		la 'i'; putchar;
		la 't'; putchar;
		la '\ '; putchar;
		la 'e'; putchar;
		la 'r'; putchar;
		la 'r'; putchar;
		la '\ '; putchar;
		bpush;proc_printbytehex;bpop;
		la '\r'; putchar; la '\n'; putchar;interrupt;
		sc %libc_krenel_cswitch_killtask%; jmp;
	libc_krenel_syscall:
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~ KRENEL SYSCALL IMPLEMENTATIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			user_geta;	lb 0xa; cmp; sc %libc_krenel_syscall_flush_stdout%; jmpifeq;
			user_geta;	lb 0xc; cmp; sc %libc_krenel_syscall_clear_term%; jmpifeq;
			user_geta;	lb 0xd; cmp; sc %libc_krenel_syscall_flush_stdout%; jmpifeq;
			user_geta;	nota; sc %libc_krenel_syscall_flush_stdout%; jmpifeq;
			user_geta;	sc %libc_krenel_syscall_pumpevents%; jmpifeq; 						//Already 1!
			user_geta;	lb 2; cmp; sc %libc_krenel_syscall_read_gamer_buttons%; jmpifeq;
			user_geta;	lb 3; cmp; sc %libc_krenel_syscall_play_audio%; jmpifeq;
			user_geta;	lb 4; cmp; sc %libc_krenel_syscall_kill_audio%; jmpifeq;
			user_geta;	lb 5; cmp; sc %libc_krenel_syscall_set_colors%; jmpifeq;
			user_geta;	lb 7; cmp; sc %libc_krenel_syscall_become_av_provider%; jmpifeq;
			user_geta;	lb 8; cmp; sc %libc_krenel_syscall_set_palette_color%; jmpifeq;
			user_geta;	llb %0xDEAD%; cmp; sc %libc_krenel_shutdown%; jmpifeq;
			user_geta;	llb %0xDE00%; cmp; sc %libc_krenel_syscall_kill_pid%; jmpifeq;
			user_geta;	llb %0xDE01%; cmp; sc %libc_krenel_syscall_disk_write%; jmpifeq;
			user_geta;	llb %0xDE02%; cmp; sc %libc_krenel_try_select_task%; jmpifeq;		//Sleep.
			user_geta;	llb %0xDE03%; cmp; sc %libc_krenel_syscall_disk_read%; jmpifeq;
			user_geta;	llb %0xDE04%; cmp; sc %libc_krenel_syscall_exec%; jmpifeq;
			user_geta;	llb %0xDE05%; cmp; sc %libc_krenel_syscall_ipc_write%; jmpifeq;
			user_geta;	llb %0xDE06%; cmp; sc %libc_krenel_syscall_fork%; jmpifeq;
			user_geta;	llb %0xDE07%; cmp; sc %libc_krenel_syscall_getpid%; jmpifeq;
			//I don't recognize this syscall. 
			libc_lproc_krenel_print_krenel;
			la 'b'; putchar;
			la 'a'; putchar;
			la 'd'; putchar;
			la '\ '; putchar;
			la 's'; putchar;
			la 'y'; putchar;
			la 's'; putchar;
			la 'c'; putchar;
			la 'a'; putchar;
			la 'l'; putchar;
			la 'l'; putchar;
			la '\r'; putchar;
			la '\n'; putchar;interrupt;
			sc %libc_krenel_cswitch_killtask%; jmp;
		:libc_krenel_syscall_getpid:
			farllda %~LIBC_REGION%, %libc_krenel_active_task_index%;
			user_seta;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_ipc_write:
			user_get0; //The location in memory to write it.
			cbrx0;
			user_getb;apush; //the byte you want to write.
			user_getc; //the machine they want to interact with.
			task_set;
			apop;
			user_farista;	//write it!
			//Re-set our active task.
			farllda %~LIBC_REGION%, %libc_krenel_active_task_index%;
			task_set;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_kill_pid:
			//did the user ask us to kill them?
			user_getb;
			lb libc_krenel_max_active_tasks_mask; 
			and;
			apush;
			farlldb %~LIBC_REGION%, %libc_krenel_active_task_index%;
			cmp; bpop; sc %libc_krenel_cswitch_killtask%; jmpifeq;

			ab;apush;
			lb 2;mul;ba;sc %LIBC_REGION%;lla %libc_krenel_task_isactive_array%;
			add;ba;
			la 0; faristla;
			
			//also set it as killed in the CPU.
			apop;task_set; task_kill;

			//Re-set our active task.
			farllda %~LIBC_REGION%, %libc_krenel_active_task_index%;
			task_set;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_flush_stdout:
			la '\n'; interrupt; //This also displays the screen.
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_clear_term:
			la 0xc; interrupt;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_pumpevents:
			la 1; interrupt;
			llb %0xffFF%; cmp; sc %libc_krenel_shutdown%; jmpifeq; //handle quit.
			user_seta;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_read_gamer_buttons:
			la 2; interrupt;
			user_seta;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_kill_audio:
			//Anyone on the system can request to kill the audio.
			la 4; interrupt; 
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_become_av_provider:
			farllda %~LIBC_REGION%, %libc_krenel_active_task_index%;
			aincr; ba;
			la 7; interrupt;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_set_palette_color:
			user_get0;
			user_getb; ba;
			la 8; interrupt;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_play_audio:
			la 3; interrupt; 
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_set_colors:
			user_getb;ba;
			la 5; interrupt;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_disk_write:
			//Write a single sector to disk.
			//RX0: Destination on disk. Not aligned!
			//B: source page.
			//Check permissions.
			user_get0;
			lrx1 %/libc_krenel_disk_reserved%;
			rxcmp;
			lb 2;
			cmp;
			sc %libc_krenel_bad_disk_write%; jmpifneq; //If they aren't writing past the first 512k, kill them.
			libc_lproc_krenel_load_user_page;
			user_get0;
			llb %libc_krenel_diskio_page%; 
			lla %0xFF11%; //Syscall to write 256 bytes to disk.
			interrupt;
			user_seta; //Inform the user if the disk write succeeded.
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_bad_disk_write:
			//print an error message.
			libc_lproc_krenel_print_krenel;
			la 'b'; putchar;
			la 'a'; putchar;
			la 'd'; putchar;
			la ' '; putchar;
			la 'd'; putchar;
			la 'i'; putchar;
			la 's'; putchar;
			la 'k'; putchar;
			la ' '; putchar;
			la 'w'; putchar;
			la 'r'; putchar;
			la 'i'; putchar;
			la 't'; putchar;
			la 'e'; putchar;
			la '\r'; putchar;
			la '\n'; putchar;interrupt;
			sc %libc_krenel_cswitch_killtask%; jmp;
		:libc_krenel_syscall_disk_read:
			//read a single sector from disk.
			//RX0: source sector in disk. Not aligned!
			//B: destination memory page in user memory.
			user_get0;
			llb %libc_krenel_diskio_page%;
			lla %0xFF10%; //Disk Read magic number.
			interrupt;
			user_seta; //Inform the user if the disk read succeeded.
			//We now have to actually *copy* that stuff over to user memory.
			user_getb; ca;
			lla %libc_krenel_diskio_page%;
			user_farpagest;
			sc %libc_krenel_syscall_end%; jmp;
			//Old implementation of the copy.
		:libc_krenel_syscall_exec:
			user_getb;			//The region;
			lb 8; lsh;			//times 256.
			rx0a;				//put it in RX0.
			rx3_0; 
			lrx1 %/0x100%;rxadd;
			rx1_0;
			rx0_3;

			//Copy memory by page.
			libc_krenel_syscall_exec_copymem_looptop:
				arx0;
				lb 255; and;
				llb libc_krenel_exec_region,0;
				add;
				crx0;		//Destination page.
				user_farpagel; //USER farpagel
				rxincr;rxcmp;nota; //if(++rx0 < rx1)
				sc %libc_krenel_syscall_exec_copymem_looptop%; jmpifeq; //continue looping.

			//The memory is copied. We must now find a free PID.
			lrx1 %/libc_krenel_max_active_tasks%; lb 0; rx0b;
			libc_krenel_syscall_exec_findfreepid_looptop:
				arx0;
				lb 2;mul;ba
				sc %LIBC_REGION%;
				lla %libc_krenel_task_isactive_array%;
				add;ba;
				farillda;
				nota;
				sc %libc_krenel_syscall_exec_found_that_pid%; jmpifeq;
				rxincr;rxcmp;
				sc %libc_krenel_syscall_exec_failure%; jmpifeq;
				sc %libc_krenel_syscall_exec_findfreepid_looptop%; jmp;
			
			libc_krenel_syscall_exec_found_that_pid:
				//First, tell our previous user that we succeeded.
				la 1;user_seta;
				la 0; farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;	//Reset the number of returns for our old task.
				//It is in RX0.
				arx0;task_set;
				farstla %~LIBC_REGION%, %libc_krenel_active_task_index%;

				//Mark it as running.
				lb 2; mul; ba;
				sc %LIBC_REGION%;
				lla %libc_krenel_task_isactive_array%;
				add;ba;
				la 1; faristla;

				//Create a bootloader
				//We're execing the at *our* assigned location, because that's where we copied it!
				lrx0 0,libc_krenel_exec_region,0,0
				farstrx0 %~LIBC_REGION%, %libc_krenel_jumploc%;
			//We must copy three bytes, so we do 4 for speed's sake.
				farldrx0 %&0%
				farstrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
				sc %0%; la 2; ista; //la
				adecr;ca;			//put 1 into c.
				lla %~LIBC_REGION%, 0x44; istla;	//0x44 is the code for lfarpc.
				emulate;
			//restore stack integrity.
				farldrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
				farstrx0 %&0%
				//We have switched task, as commanded. A holds our return value. CHECK IT...
				sc %libc_krenel_cswitch_looptop%; jmp;
			libc_krenel_syscall_exec_failure:
				la 0;user_seta;
				sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_fork:
			//Find a free pid.
			lrx1 %/libc_krenel_max_active_tasks%; 
			lb 0; rx0b;
			libc_krenel_syscall_fork_findfreepid_looptop:
				arx0;
				lb 2;mul;ba
				sc %LIBC_REGION%;
				lla %libc_krenel_task_isactive_array%;
				add;ba;
				farillda;
				nota;
				sc %libc_krenel_syscall_fork_found_that_pid%; jmpifeq;
				rxincr;rxcmp;
				sc %libc_krenel_syscall_fork_failure%; jmpifeq;
				sc %libc_krenel_syscall_fork_findfreepid_looptop%; jmp;
			
			libc_krenel_syscall_fork_found_that_pid:
				//First, tell our previous user that we succeeded.
				la 1; user_seta;
				la 0; farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;	//Reset the number of returns.
				//The new PID is in RX0.
				arx0;apush;
				
				lb 0; rx0b;
				lrx1 %/0x10000%; //The end of memory, as a page.
				libc_krenel_syscall_fork_copymem_looptop:
					lla %libc_krenel_diskio_page%;;
					crx0;
					user_farpagel;
					apop;apush;task_set; //Into new user memory.
					lla %libc_krenel_diskio_page%;;
					user_farpagest;
					farllda %~LIBC_REGION%, %libc_krenel_active_task_index%;
					task_set;
					rxincr;rxcmp;nota; 
					sc %libc_krenel_syscall_fork_copymem_looptop%; jmpifeq; //if(++rx0 < rx1) jmp

				apop; task_set; farstla %~LIBC_REGION%, %libc_krenel_active_task_index%;
				

				//Mark it as running.
				lb 2; mul; ba;
				sc %LIBC_REGION%;
				lla %libc_krenel_task_isactive_array%;
				add;ba;
				la 1; faristla;
				task_kill; //Reset it.
				//Unlike exec, we do not need to create a bootloader. Fork assumes that the userland code already did that.
				priv_drop;
				//We have switched task and returned, as commanded. A holds our return value. CHECK IT...
				sc %libc_krenel_cswitch_looptop%; jmp;
			libc_krenel_syscall_fork_failure:
				la 0;user_seta;
				sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_end:
			//Syscalls are expensive.
			farllda %~LIBC_REGION%, %libc_krenel_task_nreturns%;
			lb 5; add;
			farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;
			sc %libc_krenel_preempt%; jmp;
	libc_krenel_getchar:
		getchar;user_seta;sc %libc_krenel_preempt%; jmp;
	libc_krenel_putchar:
		user_geta;putchar;sc %libc_krenel_preempt%; jmp;
	libc_krenel_tried_interrupt:
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~KRENEL INTERRUPT PASSTHROUGHS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		user_geta; lb '\n'; cmp; sc %libc_krenel_syscall_flush_stdout%; jmpifeq;
		user_geta; lb '\r'; cmp;  sc %libc_krenel_syscall_flush_stdout%; jmpifeq;
		user_geta; lb 0xc; cmp; sc %libc_krenel_syscall_clear_term%; jmpifeq;
		user_geta; lb 1; cmp; sc %libc_krenel_syscall_pumpevents%; jmpifeq;
		user_geta; lb 3; cmp; sc %libc_krenel_syscall_play_audio%; jmpifeq;
		user_geta; lb 4; cmp; sc %libc_krenel_syscall_kill_audio%; jmpifeq;
		user_geta; lb 5; cmp; sc %libc_krenel_syscall_set_colors%; jmpifeq;
		user_geta; lb 7; cmp; sc %libc_krenel_syscall_become_av_provider%; jmpifeq;
		user_geta; lb 8; cmp; sc %libc_krenel_syscall_set_palette_color%; jmpifeq;
		user_geta; lb 0x80; cmp;  sc %libc_krenel_try_select_task%; jmpifeq; //Interrupt 0x80 just selects the next task.
		//BAD INTERRUPT
		la '\r'; putchar; la '\n'; putchar;
		libc_lproc_krenel_print_krenel;
		la 'i'; putchar;
		la 'l'; putchar;
		la 'l'; putchar;
		la '\ '; putchar;
		la 'i'; putchar;
		la 'n'; putchar;
		la 't'; putchar;
		la '\r'; putchar;
		la '\n'; putchar;interrupt;
		sc %libc_krenel_cswitch_killtask%; jmp;
	libc_krenel_preempt:
		//Check for need of a task switch.
		farllda %~LIBC_REGION%, %libc_krenel_task_nreturns%;
		aincr;
		farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;
		llb %libc_krenel_max_returns%; cmp; lb 2; cmp; sc %libc_krenel_try_select_task%; jmpifeq;
		priv_drop;
		sc %libc_krenel_cswitch_looptop%; jmp;
	libc_krenel_cswitch_killtask:
		//Kill the current task.
			task_kill;
		//Set active task to be in the "dead" state- 0.
			farllda %~LIBC_REGION%, %libc_krenel_active_task_index%;
			lb libc_krenel_max_active_tasks_mask; and;
			lb 2;mul;ba;
			sc %LIBC_REGION%;
			lla %libc_krenel_task_isactive_array%;
			add;ba;
			la 0; faristla;
		//Try to select a task.
			//sc %libc_krenel_try_select_task%; jmp;
	libc_krenel_try_select_task:
		task_ric; //Reset the current task's instruction counter.
		la 1; interrupt; //Check for quit signal. Also pumps the keyboard...
		llb %0xffFF%; cmp; sc %libc_krenel_shutdown%; jmpifeq;
		lb 0; rx2b;	//RX2: the number of things we have tried.
		la 0; farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;	//Reset the number of returns for our old task.
		lb libc_krenel_max_active_tasks_mask; rx1b;
		farllda %~LIBC_REGION%, %libc_krenel_active_task_index%;
		rx3a;//RX3: our counter.
	libc_krenel_try_select_task_loop:
		//Loop from where we are, and around again. If we find a task to execute... execute it!
			rx0_3;
			rxincr;
			rxand; //we're using the mask.
			rx3_0;
			arx3;lb 1;lsh;ba;
			sc %LIBC_REGION%;
			lla %libc_krenel_task_isactive_array%;
			add;ba;
			farillda;
		//Did we find it? 1 is already the value for "equals" so we dont need to compare it.
			sc %libc_krenel_found_pid_to_run%; jmpifeq;
		//We didn't! Should we quit?
			rx0_2;rxincr;rx2_0;
		//It will always be at LEAST 1 after this... We have to compare with the *mask* which is one less.
			rxdecr;
			rxcmp;lb 2;cmp;sc %libc_krenel_shutdown%; jmpifeq;
		//No. Continue to search for new tasks.
			sc %libc_krenel_try_select_task_loop%; jmp;
	libc_krenel_found_pid_to_run:
		//Set it as the active PID.
		arx3;
		task_set; 
		task_ric;
		farstla %~LIBC_REGION%, %libc_krenel_active_task_index%
		priv_drop;
		sc %libc_krenel_cswitch_looptop%; jmp;
	libc_krenel_shutdown:
		//Shut down the system.
		//Loop through all the stuff. Close everything!
		//Set all tasks to be zero. task_kill everything.
		lb 0;rx0b; 
		lb libc_krenel_max_active_tasks; rx1b;
		libc_krenel_zero_tasks_shutdown_looptop:
			arx0;task_kill;
			lb 2;mul;ba;
			sc %LIBC_REGION%;lla %libc_krenel_task_isactive_array%
			add;ba;
			la 0; faristla;
			rxincr;rxcmp;nota; //nota is just "Is a equal to zero?"
			sc %libc_krenel_zero_tasks_shutdown_looptop%; jmpifeq;
		lla %0xE001%; interrupt; //make IO blocking again.
		libc_lproc_krenel_print_krenel;
		la 's'; putchar;
		la 'h'; putchar;
		la 'u'; putchar;
		la 't'; putchar;
		la 'd'; putchar;
		la 'o'; putchar;
		la 'w'; putchar;
		la 'n'; putchar;
		la '\n'; interrupt;
		farret;													asm_print; //I want information!


//If you directly boot the libc, this is what you boot into.
:libc_booter:
	//restore the nops at zero.
	la 0x1E;
	sta %0%;
	sta %1%;
	sta %2%;
	sta %3%;
	la 0; rx0a;
	lla %0x100%; rx1a;
	llb %~LIBC_REGION%, 0;
	libc_booter_copy_loop:
		arx0;  add; ca;
		arx0;
		farpagest;
		rxincr;
		rxcmp;
		nota;
		sc %libc_booter_copy_loop%; jmpifeq;
	//Indicate that booting succeded.
	astp;popa; //Clear the stack pointer.
	lrx0 %/COMMAND_COM%;
	proc_krenel;
	halt;

..include"command_com.hasm"

