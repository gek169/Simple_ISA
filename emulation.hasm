

//~~~~~~~~~~~~~~~~~~
//~~emulate_single~~
//~~~~~~~~~~~~~~~~~~
//This must be placed at a region boundary, so it must be first.
//Both of the following functions take a jump point in RX0.
//They take a page to share with the client in the second parameter, so memory can be shared.
//The return values from the machine are not provided to the caller.
//krenel also uses it.

//Copy sh*t.
farldrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
farstrx0 %&0%
.libc_krenel_jumploc:@+1+
lrx0 %/0%; 
farjmprx0;
:libc_krenel_stack_data_store:
nop;nop;nop;nop;

//Both of these functions use register B to store the page that 

..decl_farproc(LIBC_REGION):proc_emulate_single
..export"proc_emulate_single"
	//We are passed a place to jump to in RX0.
	farstrx0 %~LIBC_REGION%, %libc_krenel_jumploc%;
	//We must memcpy three bytes, so we memcpy 4.
	farldrx0 %&0%
	farstrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
	sc %0%; la 2; ista; //la
	adecr;ca;			//put 1 into c.
	lla %~LIBC_REGION%, 0x44; istla;
	ab;
	emulate;
	//restore stack integrity.
		farldrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
		farstrx0 %&0%
	//a holds the value. CHECK IT.
	blpush;
	libc_emulate_single_cswitch_looptop:
		alpush;
		lb 19; cmp; blpop; sc %libc_emulate_single_syscall%; jmpifeq;
		ab; alpush;
		lb 18; cmp; blpop; sc %libc_emulate_single_interrupt%; jmpifeq;
		ab; alpush;
		lb 17; cmp; blpop; sc %libc_emulate_single_putchar%; jmpifeq;
		ab; alpush;
		lb 16; cmp; blpop; sc %libc_emulate_single_getchar%; jmpifeq;
		ab; alpush;
		lb 0xff; cmp; blpop; sc %libc_emulate_single_preempt%; jmpifeq;
		sc %libc_emulate_single_cswitch_loopout%; jmp;
	libc_emulate_single_syscall:
		//TODO: provide services.
		sc %libc_emulate_single_preempt%; jmp;
	libc_emulate_single_interrupt:
		user_getb;ba;
		user_getc;ca;
		user_geta;
		user_get1;rx1_0;
		user_get2;rx2_0;
		user_get3;rx3_0;
		user_get0;
		interrupt;
		user_seta;
		sc %libc_emulate_single_preempt%; jmp;
	libc_emulate_single_getchar:
		getchar;
		user_seta;
		sc %libc_emulate_single_preempt%; jmp;
	libc_emulate_single_putchar:
		user_geta;
		putchar;
//		sc %libc_emulate_single_preempt%; jmp;
	libc_emulate_single_preempt:
		alpop; push %2%;
		priv_drop;
		sc %libc_emulate_single_cswitch_looptop%; jmp;
	libc_emulate_single_cswitch_loopout:
	blpop;
farret;


..include"printbytehex.hasm"
..include"fdisk.hasm"

..decl_lproc:libc_lproc_krenel_print_krenel
	la 'K'; putchar;
	la 'R'; putchar;
	la 'E'; putchar;
	la 'N'; putchar;
	la 'E'; putchar;
	la 'L'; putchar;
	la '\:'; putchar;
	la '\ '; putchar;
	ret



//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~K R E N E L~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//Give it a location to boot as PID 0, and it will, in RX0.

//krenel constants:
.libc_krenel_max_active_tasks:8
.libc_krenel_max_returns:20
.libc_krenel_exec_region:255


//Load user page according to register B.
..decl_lproc:libc_lproc_krenel_load_user_page
	user_getb;rx0a;
	lb 8; rx1b; rxlsh;
	rx2_0;
	lrx1 %/0x100%;rxadd;
	rx1_0;
	//construct the destimation in rx3.
	lrx3 %libc_krenel_exec_region%,0,0;
	rx0_2;
	libc_lproc_krenel_load_user_page_loop:
		cbrx0; user_farilda;
		rx0_3;cbrx0;
		farista;
		rx0_3;rxincr;rx3_0;
		rx0_2;rxincr;rx2_0;
		rxcmp;
		nota; //A is zero, meaning that RX0 is less than RX1 throughout the loop.
		sc %libc_lproc_krenel_load_user_page_loop%; jmpifeq;
	ret;

//all tasks start out as 0- inactive.
//these are shorts.
:libc_krenel_task_isactive_array:
bytes 0,0,  0,0;
bytes 0,0,  0,0;
bytes 0,0,  0,0;
bytes 0,0,  0,0;
bytes 0,0,  0,0;
bytes 0,0,  0,0;
bytes 0,0,  0,0;


:libc_krenel_task_nreturns:
bytes 0,0;

:libc_krenel_active_task_index:
bytes 0,0;

..decl_farproc(LIBC_REGION):proc_krenel
..export"proc_krenel"
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~ KRENEL STARTUP ROUTINE ~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		libc_lproc_krenel_print_krenel;
		la 'B'; putchar;
		la 'O'; putchar;
		la 'O'; putchar;
		la 'T'; putchar;
		la '\n'; putchar;
		la '\r'; putchar;
		la '\n'; interrupt;
	//We are passed a place to jump to in RX0. Store it away while we set up the krenel.
		rx0push;
	//Set input mode to be non-blocking.
		lla %0xE000%; interrupt;
		
	//Set the active task's info.
		la 0; farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;	
		la 0; farstla %~LIBC_REGION%, %libc_krenel_active_task_index%;

	//Set all tasks to be zero... except the first one.
		lb0;rx0b; 
		lb libc_krenel_max_active_tasks; rx1b;
		libc_krenel_zero_tasks_looptop:
			arx0;lb 2;mul;ba;
			sc %LIBC_REGION%;lla %libc_krenel_task_isactive_array%
			add;ba;
			la 0; faristla;
			rxincr;rxcmp;nota; //nota is just "Is a equal to zero?"
			sc %libc_krenel_zero_tasks_looptop%; jmpifeq;
	//PID 0 is the initial program...
		sc %LIBC_REGION%;llb %libc_krenel_task_isactive_array%
		la 1;
		farstla %~LIBC_REGION%,  %libc_krenel_task_isactive_array%;
	//get that important argument back!
		rx0pop;
		farstrx0 %~LIBC_REGION%, %libc_krenel_jumploc%;
	//We must copy three bytes, so we do 4 for speed's sake.
		farldrx0 %&0%
		farstrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
		sc %0%; la 2; ista; //la
		adecr;ca;			//put 1 into c.
		lla %~LIBC_REGION%, 0x44; istla;	//0x44 is the code for lfarpc.
		emulate;
	//restore stack integrity.
		farldrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
		farstrx0 %&0%
	//a holds the return value. CHECK IT.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~ KRENEL SCHEDULER ROUTINE ~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	libc_krenel_cswitch_looptop:
		alpush; 
		lb 0xff; cmp; blpop; sc %libc_krenel_was_preempted%; jmpifeq;
		ab; alpush;
		lb 19; cmp; blpop; sc %libc_krenel_syscall%; jmpifeq;
		ab; alpush;
		lb 18; cmp; blpop; sc %libc_krenel_tried_interrupt%; jmpifeq; //might as well print out an error message.
		ab; alpush;
		lb 17; cmp; blpop; sc %libc_krenel_putchar%; jmpifeq;
		ab; alpush;
		lb 16; cmp; blpop; sc %libc_krenel_getchar%; jmpifeq;
		ab; alpush;
		lb 0; cmp; blpop; sc %libc_krenel_cswitch_killtask%; jmpifeq;
		libc_lproc_krenel_print_krenel;
		la 'e'; putchar;
		la 'r'; putchar;
		la 'r'; putchar;
		la 'o'; putchar;
		la 'r'; putchar;
		la '\ '; putchar;
		bpush;proc_printbytehex;bpop;
		la '\r'; putchar;
		la '\n'; putchar;
		la '\n'; interrupt;
		sc %libc_krenel_cswitch_killtask%; jmp;
	libc_krenel_syscall:
		//TODO: provide services based on user registers.
		//Needed services:
		//Kill pid-					Kill another process.
		//Shutdown-					Kill the system.
		//Exec-						load a single region of code
		//Interrupt passthroughs-	allow certain interrupts to be called, such as '\n'.
		//Disk Read Sector-			Read a 256 byte sector from disk.
		//Disk Write Sector-		write a 256 byte sector to disk.
		//Interprocess Write-		Write to another process's memory.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~ KRENEL SYSCALL IMPLEMENTATIONS ~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			user_geta;	lb '\n'; cmp; sc %libc_krenel_syscall_flush_stdout%; jmpifeq;
			user_geta;	lb '\r'; cmp; sc %libc_krenel_syscall_flush_stdout%; jmpifeq;
			user_geta;	llb %0xDEAD%; cmp; sc %libc_krenel_shutdown%; jmpifeq;
			user_geta;	llb %0xDE00%; cmp; sc %libc_krenel_syscall_kill_pid%; jmpifeq;
			user_geta;	llb %0xDE01%; cmp; sc %libc_krenel_syscall_disk_write%; jmpifeq;
			user_geta;	llb %0xDE02%; cmp; sc %libc_krenel_syscall_sleep%; jmpifeq;
			user_geta;	llb %0xDE03%; cmp; sc %libc_krenel_syscall_disk_read%; jmpifeq;
			user_geta;	llb %0xDE04%; cmp; sc %libc_krenel_syscall_exec%; jmpifeq;
			user_geta;	llb %0xDE05%; cmp; sc %libc_krenel_syscall_ipc_write%; jmpifeq;
		//I don't recognize this syscall. Just ignore it... for now.
		sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_ipc_write:
			user_get0; //The location in memory to write it.
			cbrx0;
			user_getb;apush; //the byte you want to write.
			user_getc; //the machine they want to interact with.
			task_set;
			apop;
			user_farista;	//write it!
			//Re-set our active task.
			farllda %~LIBC_REGION%, %libc_krenel_active_task_index%;
			task_set;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_kill_pid:
			user_getb;
			lb libc_krenel_max_active_tasks; mod;
			lb 2;mul;ba;sc %LIBC_REGION%;lla %libc_krenel_task_isactive_array%;
			add;ba;

			//also set it as killed in the CPU.
			user_getb;
			lb libc_krenel_max_active_tasks; mod;
			task_set; task_kill;

			//Re-set our active task.
			farllda %~LIBC_REGION%, %libc_krenel_active_task_index%;
			task_set;
			
			la 0; faristla;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_flush_stdout:
			la '\n'; interrupt; 
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_disk_write:
			//Write a single sector to disk.
			//RX0: Destination on disk. Not aligned!
			//A: source page.
			libc_lproc_krenel_load_user_page;
			user_get0;
			llb %0xFF00%;
			lla %0xFF11%;
			interrupt;
			user_seta; //Inform the user if the disk write succeeded.
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_sleep:
			//Simply force a task switch.
			sc %libc_krenel_try_select_task%; jmp;
		:libc_krenel_syscall_disk_read:
			//read a single sector from disk.
			//RX0: source sector in disk. Not aligned!
			//B: destination memory page in user memory.
			user_get0;
			llb %0xFF00%;
			lla %0xFF10%;
			interrupt;
			user_seta; //Inform the user if the disk read succeeded.
			//We now have to actually *copy* that stuff over to user memory.
			user_getb;rx0a;
			lb 8; rx1b; rxlsh;
			rx3_0;
			lrx2 %/0xFF0000%;
			lrx1 %/0xFF0100%;
			:libc_krenel_syscall_disk_read_loop:
				rx0_2;
					cbrx0;
					farilda;
				rx0_3;cbrx0;
					user_farista;
				rxincr; rx3_0;
				rx0_2; rxincr; rx2_0;
				rxcmp; sc %libc_krenel_syscall_disk_read_loop%; jmpifneq;
			sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_exec:
			user_getb;			//The region;
			
			lb 8; lsh;			//times 256
			rx0a; lb 8; rx1b; rxlsh;rx3_0; //again...
			lrx1 %/0x10000%;rxadd;
			rx1_0;
			rx0_3;
			libc_krenel_syscall_exec_copymem_looptop:
				cbrx0; user_farilda;
				sc %libc_krenel_exec_region%; 
				farista;
				rxincr;rxcmp;lb 0;cmp; //++rx0 < rx1
				sc %libc_krenel_syscall_exec_copymem_looptop%; jmpifeq;

			//The memory is copied. We must now find a free PID.
			lrx1 %/libc_krenel_max_active_tasks%; lb 0; rx0b;
			libc_krenel_syscall_exec_findfreepid_looptop:
				arx0;
				lb 2;mul;ba
				sc %LIBC_REGION%;
				lla %libc_krenel_task_isactive_array%;
				add;ba;
				farillda;
				nota;
				sc %libc_krenel_syscall_exec_found_that_pid%; jmpifeq;
				rxincr;rxcmp;
				sc %libc_krenel_syscall_exec_failure%; jmpifeq;
				sc %libc_krenel_syscall_exec_findfreepid_looptop%; jmp;
			
			libc_krenel_syscall_exec_found_that_pid:
				//First, tell our previous user that we succeeded.
				la 1;user_seta;
				la 0; farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;	//Reset the number of returns for our old task.
				//It is in RX0.
				arx0;task_set;
				farstla %~LIBC_REGION%, %libc_krenel_active_task_index%;

				//Mark it as running.
				lb 2; mul; ba;
				sc %LIBC_REGION%;
				lla %libc_krenel_task_isactive_array%;
				add;ba;
				la 1; faristla;

				//Create a bootloader
				//We're execing the at *our* assigned location, because that's where we copied it!
				lrx0 0,libc_krenel_exec_region,0,0
				farstrx0 %~LIBC_REGION%, %libc_krenel_jumploc%;
			//We must copy three bytes, so we do 4 for speed's sake.
				farldrx0 %&0%
				farstrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
				sc %0%; la 2; ista; //la
				adecr;ca;			//put 1 into c.
				lla %~LIBC_REGION%, 0x44; istla;	//0x44 is the code for lfarpc.
				emulate;
			//restore stack integrity.
				farldrx0 %~LIBC_REGION%, %libc_krenel_stack_data_store%
				farstrx0 %&0%
				//We have switched task, as commanded. A holds our return value. CHECK IT...
				sc %libc_krenel_cswitch_looptop%; jmp;
			libc_krenel_syscall_exec_failure:
				la 0;user_seta;
				sc %libc_krenel_syscall_end%; jmp;
		:libc_krenel_syscall_end:
			//Syscalls are expensive. Increment an extra time, just to punish them!
			farllda %~LIBC_REGION%, %libc_krenel_task_nreturns%;
			aincr;
			farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;
			sc %libc_krenel_preempt%; jmp;
	libc_krenel_getchar:
		getchar;
		user_seta;
		sc %libc_krenel_preempt%; jmp;
	libc_krenel_putchar:
		user_geta;
		putchar;
		sc %libc_krenel_preempt%; jmp;
	libc_krenel_tried_interrupt:

		user_geta; alpush; lb '\n'; cmp; blpop; sc %libc_krenel_syscall_flush_stdout%; jmpifeq;
		ab; lb '\r'; cmp; sc %libc_krenel_syscall_flush_stdout%; jmpifeq;
		la 'k'; putchar;
		la 'i'; putchar;
		la 'l'; putchar;
		la 'l'; putchar;
		la 'e'; putchar;
		la 'd'; putchar;
		la '\ '; putchar;
		la 'i'; putchar;
		la 'n'; putchar;
		la 't'; putchar;
		la '\r'; putchar;
		la '\n'; putchar;
		la '\n'; interrupt;
		sc %libc_krenel_cswitch_killtask%; jmp;
	libc_krenel_was_preempted:
		lla %libc_krenel_max_returns%;
		farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;
		//Roll directly into preempt.
	libc_krenel_preempt:
		//Check for need of a task switch.
		farllda %~LIBC_REGION%, %libc_krenel_task_nreturns%;
		aincr;
		farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;
		llb %libc_krenel_max_returns%; cmp; lb 2; cmp; sc %libc_krenel_try_select_task%; jmpifeq;
	libc_krenel_really_preempt:
		priv_drop;
		sc %libc_krenel_cswitch_looptop%; jmp;
	libc_krenel_cswitch_killtask:
		//Kill the current task.
			task_kill;
		//Set active task to be in the "dead" state- 0.
			farllda %~LIBC_REGION%, %libc_krenel_active_task_index%;
			lb libc_krenel_max_active_tasks; mod;
			lb 2;mul;ba;
			sc %LIBC_REGION%;
			lla %libc_krenel_task_isactive_array%;
			add;ba;
			la 0; faristla;
		//Try to select a task.
			//sc %libc_krenel_try_select_task%; jmp;
	libc_krenel_try_select_task:
		//la 's';putchar;putchar;putchar; //DEBUG
		//la 'f'; putchar; la '\n'; interrupt; //MORE DEBUG
		lb 0; rx0b;
		la 0; farstla %~LIBC_REGION%, %libc_krenel_task_nreturns%;	//Reset the number of returns for our old task.
		lb libc_krenel_max_active_tasks; rx1b;
	libc_krenel_try_select_task_loop:
		//Loop from where we are, and around again. If we find a task to execute... execute it!
			farllda %~LIBC_REGION%, %libc_krenel_active_task_index%;
			aincr; lb libc_krenel_max_active_tasks; mod;
			farstla %~LIBC_REGION%, %libc_krenel_active_task_index%;
			task_set;
			lb 2;mul;ba
			sc %LIBC_REGION%;
			lla %libc_krenel_task_isactive_array%;
			add;ba;
			farillda;
		//Did we find it? 1 is already the value for "equals" so we dont need to compare it.
			sc %libc_krenel_really_preempt%; jmpifeq;
		//We didn't! Should we quit?
			rxincr
			rxcmp
			lb 2
			cmp
			sc %libc_krenel_shutdown%; jmpifeq;
		//No. Continue to search for new tasks.
			sc %libc_krenel_try_select_task_loop%; jmp;


	libc_krenel_shutdown:
		//Shut down the system.
		lla %0xE001%; interrupt; //make IO blocking again.
		farret;													asm_print; //I want information!
